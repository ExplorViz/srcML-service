
#C++ srcML

<table>
    <thead>
        <tr>
            <th>Language Element</th>
            <th>Elements</th>
            <th>Subelements</th>
        </tr>
    </thead>
    <tbody>
</tbody><thead>
        <tr>
            <th align="left" colspan="3"><b>FIXME: Not sorted!</b></th>
        </tr>
        </thead><tbody>

        <tr>
            <td><a href="#array-access">Array Access</a> </td>
            <td>&lt;name&gt;</td>
            <td>&lt;name&gt;, &lt;index&gt;</td>
        </tr>

        <tr>
            <td><a href="#function-call">Function Call</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;name&gt;, &lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#member-access">Member Access</a> </td>
            <td>&lt;expr&gt;</td>
            <td>&lt;name&gt;, &lt;op:operator&gt;</td>
        </tr>

        <tr>
            <td><a href="#dereference-member-access">Dereference Member Access</a> </td>
            <td>&lt;expr&gt;</td>
            <td>&lt;name&gt;, &lt;op:operator&gt;</td>
        </tr>

        <tr>
            <td><a href="#sizeof">sizeof</a> </td>
            <td>&lt;sizeof&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#cast">Cast</a> </td>
            <td>&lt;op:operator&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#variable-declaration">Variable Declaration</a> </td>
            <td>&lt;decl&gt;</td>
            <td>&lt;init&gt;</td>
        </tr>

        <tr>
            <td><a href="#variable-declaration-statement">Variable Declaration Statement</a> </td>
            <td>&lt;decl_stmt&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#const">const</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#const-funciton">const Funciton</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#extern-block">extern Block</a> </td>
            <td>&lt;extern&gt;</td>
            <td>&lt;lit:literal&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#extern-specifier">extern Specifier</a> </td>
            <td>&lt;specifier&gt;</td>
            <td>&lt;lit:literal&gt;, &lt;decl_stmt&gt;, &lt;function_stmt&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#auto-specifier">auto Specifier</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#auto-type">auto Type</a> </td>
            <td>&lt;name&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#static">static</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#typedef">typedef</a> </td>
            <td>&lt;typedef&gt;</td>
            <td>&lt;type&gt;, &lt;name&gt;, &lt;function_decl&gt;</td>
        </tr>

        <tr>
            <td><a href="#register">register</a> </td>
            <td>&lt;name&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#restrict">restrict</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#volatile">volatile</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#inline">inline</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#struct-definition">struct Definition</a> </td>
            <td>&lt;struct&gt;</td>
            <td>&lt;name&gt;, &lt;super&gt;</td>
        </tr>

        <tr>
            <td><a href="#struct-declaration">struct Declaration</a> </td>
            <td>&lt;struct_decl&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#bitfield">Bitfield</a> </td>
            <td>&lt;range&gt;</td>
            <td>&lt;lit:literal&gt;, &lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#struct-varaiable-initialization">struct Varaiable Initialization</a> </td>
            <td>&lt;decl_stmt&gt;</td>
            <td>&lt;decl&gt;, &lt;init&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#union-declaration">union Declaration</a> </td>
            <td>&lt;union_decl&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#union-definition">union Definition</a> </td>
            <td>&lt;union&gt;</td>
            <td>&lt;name&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#enum-declaration">enum Declaration</a> </td>
            <td>&lt;enum&gt;</td>
            <td>&lt;name&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#array-declaration">Array Declaration</a> </td>
            <td>&lt;decl&gt;</td>
            <td>&lt;name&gt;, &lt;index&gt;</td>
        </tr>

        <tr>
            <td><a href="#array-declaration-initialization">Array Declaration Initialization</a> </td>
            <td>&lt;init&gt;</td>
            <td>&lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#pointer-declaration">Pointer Declaration</a> </td>
            <td>&lt;type:modifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#function-declaration">Function Declaration</a> </td>
            <td>&lt;function_decl&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;param&gt;</td>
        </tr>

        <tr>
            <td><a href="#function-definition">Function Definition</a> </td>
            <td>&lt;function&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;param&gt;</td>
        </tr>

        <tr>
            <td><a href="#function-call">Function Call</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;name&gt;, &lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#break">break</a> </td>
            <td>&lt;break&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#block">Block</a> </td>
            <td>&lt;block&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#continue-statement">continue Statement</a> </td>
            <td>&lt;continue&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#do-while-statement">do while Statement</a> </td>
            <td>&lt;do&gt;</td>
            <td>&lt;block&gt;, &lt;condition&gt;</td>
        </tr>

        <tr>
            <td><a href="#for-statement">for Statement</a> </td>
            <td>&lt;for&gt;</td>
            <td>&lt;init&gt;, &lt;condition&gt;, &lt;incr&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#goto-statement">goto Statement</a> </td>
            <td>&lt;goto&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#label-statement">Label Statement</a> </td>
            <td>&lt;label&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#if-statement">if Statement</a> </td>
            <td>&lt;if&gt;</td>
            <td>&lt;else&gt;, &lt;elseif&gt;, &lt;condition&gt;, &lt;block&gt;, &lt;then&gt;</td>
        </tr>

        <tr>
            <td><a href="#empty-statement">Empty Statement</a> </td>
            <td>&lt;empty_stmt&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#return">return</a> </td>
            <td>&lt;return&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#switch-statements">switch Statements</a> </td>
            <td>&lt;switch&gt;</td>
            <td>&lt;case&gt;, &lt;condition&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#case-statements">case Statements</a> </td>
            <td>&lt;case&gt;</td>
            <td>&lt;expr&gt;</td>
        </tr>

        <tr>
            <td><a href="#while-statement">while Statement</a> </td>
            <td>&lt;while&gt;</td>
            <td>&lt;condition&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#new">new</a> </td>
            <td>&lt;op:operator&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#reference-declaration">Reference Declaration</a> </td>
            <td>&lt;type:modifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#static_cast">static_cast</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#dynamic_cast">dynamic_cast</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#reinterpret_cast">reinterpret_cast</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#delete">delete</a> </td>
            <td>&lt;op:operator&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#typeid">typeid</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#noexcept">noexcept</a> </td>
            <td>&lt;noexcept&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#alignof">alignof</a> </td>
            <td>&lt;alignof&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#constexpr">constexpr</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#alignas">alignas</a> </td>
            <td>&lt;alignas&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#namespace">namespace</a> </td>
            <td>&lt;namespace&gt;</td>
            <td>&lt;name&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#thread_local">thread_local</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#decltype">decltype</a> </td>
            <td>&lt;decltype&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#type-aliasing">Type Aliasing</a> </td>
            <td>&lt;using&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#attribute">Attribute</a> </td>
            <td>&lt;attribute&gt;</td>
            <td>&lt;expr&gt;</td>
        </tr>

        <tr>
            <td><a href="#initialization-with-an-initialization_list">Initialization with an initialization_list</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#default-function-arguments">Default Function Arguments</a> </td>
            <td>&lt;init&gt;</td>
            <td>&lt;expr&gt;</td>
        </tr>

        <tr>
            <td><a href="#rvalue-reference">RValue Reference</a> </td>
            <td>&lt;type:modifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#lamda-expression">Lamda Expression</a> </td>
            <td>&lt;lambda&gt;</td>
            <td>&lt;parameter_list&gt;, &lt;param&gt;, &lt;capture&gt;, &lt;argument&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#throw">throw</a> </td>
            <td>&lt;throw&gt;</td>
            <td>&lt;expr&gt;</td>
        </tr>

        <tr>
            <td><a href="#try">try</a> </td>
            <td>&lt;try&gt;</td>
            <td>&lt;block&gt;, &lt;catch&gt;</td>
        </tr>

        <tr>
            <td><a href="#catch">catch</a> </td>
            <td>&lt;catch&gt;</td>
            <td>&lt;parameter_list&gt;, &lt;param&gt;</td>
        </tr>

        <tr>
            <td><a href="#function-try-catch">Function try-catch</a> </td>
            <td>&lt;try&gt;</td>
            <td>&lt;catch&gt;, &lt;block&gt;, &lt;member_list&gt;</td>
        </tr>

        <tr>
            <td><a href="#variadic-type-modifier">Variadic Type Modifier</a> </td>
            <td>&lt;type:modifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#final">final</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#override">override</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#class">class</a> </td>
            <td>&lt;class&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#class-declaration">class Declaration</a> </td>
            <td>&lt;class_decl&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#constructor">Constructor</a> </td>
            <td>&lt;constructor&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;param&gt;, &lt;member_list&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#constructor-declaration">Constructor Declaration</a> </td>
            <td>&lt;constructor_decl&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;param&gt;, &lt;member_list&gt;, &lt;block&gt;</td>
        </tr>

        <tr>
            <td><a href="#destructor">Destructor</a> </td>
            <td>&lt;destructor&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#destructor-declaration">Destructor Declaration</a> </td>
            <td>&lt;destructor_decl&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#friend">friend</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#using">using</a> </td>
            <td>&lt;using&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>

        <tr>
            <td><a href="#static_assert">static_assert</a> </td>
            <td>&lt;call&gt;</td>
            <td>&lt;argument_list&gt;, &lt;argument&gt;</td>
        </tr>

        <tr>
            <td><a href="#virtual">virtual</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#abstract-function">Abstract Function</a> </td>
            <td>&lt;lit:literal type="number"&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#this">this</a> </td>
            <td>&lt;name&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#deleted-function">Deleted Function</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#default-function-implementation">Default Function Implementation</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#operator-overloading-declaration">Operator Overloading Declaration</a> </td>
            <td>&lt;function_decl&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;parm&gt;</td>
        </tr>

        <tr>
            <td><a href="#operator-overloading-definition">Operator Overloading Definition</a> </td>
            <td>&lt;function&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;parm&gt;</td>
        </tr>

        <tr>
            <td><a href="#implicit-conversion-operator-definition">Implicit Conversion Operator Definition</a> </td>
            <td>&lt;function&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;parm&gt;</td>
        </tr>

        <tr>
            <td><a href="#implicit-conversion-operator-declaration">Implicit Conversion Operator Declaration</a> </td>
            <td>&lt;function&gt;</td>
            <td>&lt;name&gt;, &lt;parameter_list&gt;, &lt;parm&gt;</td>
        </tr>

        <tr>
            <td><a href="#explicit-conversion-operator-declaration">Explicit Conversion Operator Declaration</a> </td>
            <td>&lt;function_decl&gt;</td>
            <td>&lt;specifier&gt;, &lt;name&gt;, &lt;parameter_list&gt;, &lt;parm&gt;</td>
        </tr>

        <tr>
            <td><a href="#explicit-conversion-operator-definition">Explicit Conversion Operator Definition</a> </td>
            <td>&lt;function&gt;</td>
            <td>&lt;specifier&gt;, &lt;name&gt;, &lt;parameter_list&gt;, &lt;parm&gt;</td>
        </tr>

        <tr>
            <td><a href="#explict">explict</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#template">template</a> </td>
            <td>&lt;template&gt;</td>
            <td>&lt;parameter_list&gt;, &lt;parameter&gt;, &lt;typename&gt;</td>
        </tr>

        <tr>
            <td><a href="#template-specifier">template Specifier</a> </td>
            <td>&lt;specifier&gt;</td>
            <td>&lt;parameter_list&gt;, &lt;parameter&gt;, &lt;typename&gt;</td>
        </tr>

        <tr>
            <td><a href="#template-parameters">Template Parameters</a> </td>
            <td>&lt;parameter_list&gt;</td>
            <td>&lt;param&gt;</td>
        </tr>

        <tr>
            <td><a href="#enum-class">enum class</a> </td>
            <td>&lt;enum&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#default-public-visibility">Default public Visibility</a> </td>
            <td>&lt;public type="default"&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#public-visibility">public Visibility</a> </td>
            <td>&lt;public&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#default-private-visibility">Default private Visibility</a> </td>
            <td>&lt;private type="default"&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#private-visibility">private Visibility</a> </td>
            <td>&lt;private&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#protected-visibility">protected Visibility</a> </td>
            <td>&lt;protected&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#protected-inheritance-specifier">protected Inheritance Specifier</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#private-inheritance-specifier">private Inheritance Specifier</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#public-inheritance-specifier">public Inheritance Specifier</a> </td>
            <td>&lt;specifier&gt;</td>
            <td></td>
        </tr>

        <tr>
            <td><a href="#inheritance-list">Inheritance List</a> </td>
            <td>&lt;super&gt;</td>
            <td>&lt;name&gt;</td>
        </tr>
</tbody><thead>
        <tr>
            <th align="left" colspan="3"><b>Operators</b></th>
        </tr>
        </thead><tbody>

        <tr>
            <td><a href="#operators">operators</a> </td>
            <td>&lt;op:operator&gt;</td>
            <td></td>
        </tr>
</tbody></table>

## Array Access
### Element
* **&lt;name&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;index&gt;** 


### Example

```C++
a = x[5];
val = matrix[x][y];
```
```XML
<expr_stmt><expr><name>a</name> <op:operator>=</op:operator> <name><name>x</name><index>[<expr><lit:literal type="number">5</lit:literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <op:operator>=</op:operator> <name><name>matrix</name><index>[<expr><name>x</name></expr>]</index><index>[<expr><name>y</name></expr>]</index></name></expr>;</expr_stmt>
```


## Function Call
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Examples

#### Typical Function Call

```C++
int x = atoi("50");
```
```XML
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><lit:literal type="string">&quot;50&quot;</lit:literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
```


#### Explicit Operator Call

```C++
x = operator new(NewCapacityInBytes);
```
```XML
<expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <call><name>operator new</name><argument_list>(<argument><expr><name>NewCapacityInBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## Member Access
### Element
* **&lt;expr&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;op:operator&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --operator


### Example

```C++
t.tm_sec;
```
```XML
<expr_stmt><expr><name><name>t</name><op:operator>.</op:operator><name>tm_sec</name></name></expr>;</expr_stmt>
```


## Dereference Member Access
### Element
* **&lt;expr&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;op:operator&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --operator


### Example

```C++
 t->tm_sec;
```
```XML
 <expr_stmt><expr><name><name>t</name><op:operator>-&gt;</op:operator><name>tm_sec</name></name></expr>;</expr_stmt>
```


## sizeof
### Element
* **&lt;sizeof&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Examples

#### 1

```C++
sizeof(struct type);
```
```XML
<expr_stmt><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>type</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
```


#### 2

```C++
sizeof...(Args);
```
```XML
<expr_stmt><expr><sizeof>sizeof...<argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
```


## Cast
### Element
* **&lt;op:operator&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --operator

### SubElement
* **&lt;name&gt;** 


### Example

```C++
double x = 0.0;
int y = (int)x;

```
```XML
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><lit:literal type="number">0.0</lit:literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name> <init>= <expr><op:operator>(</op:operator><name>int</name><op:operator>)</op:operator><name>x</name></expr></init></decl>;</decl_stmt>

```


## Variable Declaration
### Element
* **&lt;decl&gt;** 

### SubElement
* **&lt;init&gt;** 
     * Only used when variable is initialized at declaration. See initialization examples for more details.


### Examples

#### A Trivial Example

```C++
int x;
```
```XML
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
```


#### struct, union and enum declarations

```C++
struct X y;
union X y;
enum X y;
```
```XML
<decl_stmt><decl><type>struct <name>X</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type>union <name>X</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type>enum <name>X</name></type> <name>y</name></decl>;</decl_stmt>
```


## Variable Declaration Statement
### Element
* **&lt;decl_stmt&gt;** 


### Examples

#### A Trivial Example

```C++
int x;
```
```XML
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
```


#### struct, union and enum declarations

```C++
struct X y;
union X y;
enum X y;
```
```XML
<decl_stmt><decl><type>struct <name>X</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type>union <name>X</name></type> <name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type>enum <name>X</name></type> <name>y</name></decl>;</decl_stmt>
```


## const
### Element
* **&lt;specifier&gt;** 


### Examples

#### 1

```C++
const int x;
const X y;
```
```XML
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>X</name></type> <name>y</name></decl>;</decl_stmt>
```


#### 2

```C++
int const x;
X const y;
```
```XML
<decl_stmt><decl><type><name>int</name> <specifier>const</specifier></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>X</name> <specifier>const</specifier></type> <name>y</name></decl>;</decl_stmt>
```


## const Funciton
### Element
* **&lt;specifier&gt;** 


### Example

```C++
int foo() const;
```
```XML
<function_decl><type><name>int</name></type> <name>foo</name><parameter_list>()</parameter_list> <specifier>const</specifier>;</function_decl>
```


## extern Block
### Element
* **&lt;extern&gt;** 

### SubElements
* **&lt;lit:literal&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --literal
* **&lt;block&gt;** 


### Example

#### Extern Block with Linkage Specifier

```C++
extern "C" { }
```
```XML
<extern>extern <lit:literal type="string">&quot;C&quot;</lit:literal> <block>{ }</block></extern>
```


## extern Specifier
### Element
* **&lt;specifier&gt;** 

### SubElements
* **&lt;lit:literal&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --literal
* **&lt;decl_stmt&gt;** 
* **&lt;function_stmt&gt;** 
* **&lt;block&gt;** 


### Examples

#### External Variable

```C++
extern int X;
```
```XML
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>X</name></decl>;</decl_stmt>
```


#### External Structure

```C++
extern struct Z X;
```
```XML
<decl_stmt><decl><type><specifier>extern</specifier> struct <name>Z</name></type> <name>X</name></decl>;</decl_stmt>
```


#### External Function

```C++
extern void foo();
```
```XML
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>foo</name><parameter_list>()</parameter_list>;</function_decl>
```


#### External Function with Linkage Specifier

```C++
extern "C" void foo();
```
```XML
<extern>extern <lit:literal type="string">&quot;C&quot;</lit:literal> <function_decl><type><name>void</name></type> <name>foo</name><parameter_list>()</parameter_list>;</function_decl></extern>
```


#### Extern Structure with Linkage Specifier

```C++
extern "C" struct Z X;
```
```XML
<extern>extern <lit:literal type="string">&quot;C&quot;</lit:literal> <decl_stmt><decl><type>struct <name>Z</name></type> <name>X</name></decl>;</decl_stmt></extern>
```


#### Extern Variable with Linkage Specifier

```C++
extern "C" int X;
```
```XML
<extern>extern <lit:literal type="string">&quot;C&quot;</lit:literal> <decl_stmt><decl><type><name>int</name></type> <name>X</name></decl>;</decl_stmt></extern>
```


## auto Specifier
### Element
* **&lt;specifier&gt;** 


### Example

```C++
auto int x;
```
```XML
<decl_stmt><decl><type><specifier>auto</specifier> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
```


## auto Type
### Element
* **&lt;name&gt;** 


### Examples

#### 1

```C++
auto temp() -> int { }
```
```XML
<function><type><name>auto</name></type> <name>temp</name><parameter_list>()</parameter_list> -&gt; <type><name>int</name></type> <block>{ }</block></function>
```


#### 2

```C++
auto i = 5;
```
```XML
<decl_stmt><decl><type><name>auto</name></type> <name>i</name> <init>= <expr><lit:literal type="number">5</lit:literal></expr></init></decl>;</decl_stmt>
```


## static
### Element
* **&lt;specifier&gt;** 


### Examples

#### 1

```C++
static int x;
```
```XML
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
```


#### 2

```C++
static void foo();
```
```XML
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>foo</name><parameter_list>()</parameter_list>;</function_decl>
```


## typedef
### Element
* **&lt;typedef&gt;** 

### SubElements
* **&lt;type&gt;** 
* **&lt;name&gt;** 
* **&lt;function_decl&gt;** 


### Examples

#### 1

```C++
typedef char C;
typedef unsigned int WORD;
typedef char * pChar;
typedef char field [50]; 
typedef char field, *field2; 
```
```XML
<typedef>typedef <type><name>char</name></type> <name>C</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>WORD</name>;</typedef>
<typedef>typedef <type><name>char</name> <type:modifier>*</type:modifier></type> <name>pChar</name>;</typedef>
<typedef>typedef <type><name>char</name></type> <name><name>field</name> <index>[<expr><lit:literal type="number">50</lit:literal></expr>]</index></name>;</typedef> 
<typedef>typedef <type><name>char</name></type> <name>field</name><op:operator>,</op:operator> <type:modifier>*</type:modifier><name>field2</name>;</typedef> 
```


#### 2

```C++
typedef struct club 
{
    char name[30];
    int size, year;
} GROUP;
```
```XML
<typedef>typedef <type><struct>struct <name>club</name> 
<block>{<public type="default">
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><lit:literal type="number">30</lit:literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name></decl><op:operator>,</op:operator> <name>year</name>;</decl_stmt>
</public>}</block></struct></type> <name>GROUP</name>;</typedef>
```


#### 3

```C++
typedef void DRAWF( int, int );
```
```XML
<typedef>typedef <function_decl><type><name>void</name></type> <name>DRAWF</name><parameter_list>( <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param> )</parameter_list>;</function_decl></typedef>
```


#### 4

```C++
typedef void (*DRAWF)( int, int );
```
```XML
<typedef>typedef <function_decl><type><name>void</name></type> (<type:modifier>*</type:modifier><name>DRAWF</name>)<parameter_list>( <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param> )</parameter_list>;</function_decl></typedef>
```


## register
### Element
* **&lt;name&gt;** 


### Example

```C++
register int x;
register float y;
```
```XML
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>float</name></type> <name>y</name></decl>;</decl_stmt>
```


## restrict
### Element
* **&lt;specifier&gt;** 


### Example

```C++
restrict double* x;
restrict union Z* x;
```
```XML
<decl_stmt><decl><type><specifier>restrict</specifier> <name>double</name><type:modifier>*</type:modifier></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>restrict</specifier> union <name>Z</name><type:modifier>*</type:modifier></type> <name>x</name></decl>;</decl_stmt>
```


## volatile
### Element
* **&lt;specifier&gt;** 


### Example

```C++
volatile int foo; 
int volatile foo;
```
```XML
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>foo</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <specifier>volatile</specifier></type> <name>foo</name></decl>;</decl_stmt>
```


## inline
### Element
* **&lt;specifier&gt;** 


### Examples

#### 1

```C++
inline void swapValues(int* a,int* b);
```
```XML
<function_decl><type><specifier>inline</specifier> <name>void</name></type> <name>swapValues</name><parameter_list>(<param><decl><type><name>int</name><type:modifier>*</type:modifier></type> <name>a</name></decl></param>,<param><decl><type><name>int</name><type:modifier>*</type:modifier></type> <name>b</name></decl></param>)</parameter_list>;</function_decl>
```


#### 2

```C++
inline namespace ns { }
```
```XML
<namespace><specifier>inline</specifier> namespace <name>ns</name> <block>{ }</block></namespace>
```


## struct Definition

See [Class](#class) for more examples.
### Element
* **&lt;struct&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;super&gt;** 


### Examples

#### Trivial Declaration

```C++
struct a {
    int x;
    double y;
    float z;
 };
```
```XML
<struct>struct <name>a</name> <block>{<public type="default">
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>z</name></decl>;</decl_stmt>
 </public>}</block>;</struct>
```


#### Variable Of An Anonymous Struct Type

```C++
struct
{
    int x;
    int y;
} mystruct;
```
```XML
<struct>struct
<block>{<public type="default">
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
</public>}</block> <decl><name>mystruct</name></decl>;</struct>
```


#### Declaring A Struct And Instance

```C++
struct employee
{
    char name[20];
    int id;
    long class;
} temp;
```
```XML
<struct>struct <name>employee</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><lit:literal type="number">20</lit:literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>class</name></decl>;</decl_stmt>
</public>}</block> <decl><name>temp</name></decl>;</struct>
```


## struct Declaration
### Element
* **&lt;struct_decl&gt;** 


### Example

#### Forward Declaration

```C++
struct employee;
```
```XML
<struct_decl>struct <name>employee</name>;</struct_decl>
```


## Bitfield
### Element
* **&lt;range&gt;** 

### SubElements
* **&lt;lit:literal&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --literal
* **&lt;name&gt;** 


### Example

```C++
struct mybitfields
{
    int a : 5;
} test;
```
```XML
<struct>struct <name>mybitfields</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>int</name></type> <name>a</name> <range>: <expr><lit:literal type="number">5</lit:literal></expr></range></decl>;</decl_stmt>
</public>}</block> <decl><name>test</name></decl>;</struct>
```


## struct Varaiable Initialization
### Element
* **&lt;decl_stmt&gt;** 

### SubElements
* **&lt;decl&gt;** 
* **&lt;init&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
MY_TYPE a = { false, 234, 1.234 };
```
```XML
<decl_stmt><decl><type><name>MY_TYPE</name></type> <name>a</name> <init>= <expr><block>{ <expr><lit:literal type="boolean">false</lit:literal></expr>, <expr><lit:literal type="number">234</lit:literal></expr>, <expr><lit:literal type="number">1.234</lit:literal></expr> }</block></expr></init></decl>;</decl_stmt>
```


#### 2

```C++
MY_TYPE b = (MY_TYPE) { false, 234, 1.234 };
```
```XML
<decl_stmt><decl><type><name>MY_TYPE</name></type> <name>b</name> <init>= <expr><op:operator>(</op:operator><name>MY_TYPE</name><op:operator>)</op:operator> <block>{ <expr><lit:literal type="boolean">false</lit:literal></expr>, <expr><lit:literal type="number">234</lit:literal></expr>, <expr><lit:literal type="number">1.234</lit:literal></expr> }</block></expr></init></decl>;</decl_stmt>
```


#### 3

```C++
MY_TYPE c = { .flag = true, .value = 123, .stuff = 0.456 };
```
```XML
<decl_stmt><decl><type><name>MY_TYPE</name></type> <name>c</name> <init>= <expr><block>{ <expr><op:operator>.</op:operator><name>flag</name> <op:operator>=</op:operator> <lit:literal type="boolean">true</lit:literal></expr>, <expr><op:operator>.</op:operator><name>value</name> <op:operator>=</op:operator> <lit:literal type="number">123</lit:literal></expr>, <expr><op:operator>.</op:operator><name>stuff</name> <op:operator>=</op:operator> <lit:literal type="number">0.456</lit:literal></expr> }</block></expr></init></decl>;</decl_stmt>
```


## union Declaration
### Element
* **&lt;union_decl&gt;** 

### SubElement
* **&lt;name&gt;** 


### Example

```C++
union X;
```
```XML
<union_decl>union <name>X</name>;</union_decl>
```


## union Definition
### Element
* **&lt;union&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;block&gt;** 


### Example

```C++
union sign
{
    int svar;
    unsigned uvar;
} number;
```
```XML
<union>union <name>sign</name>
<block>{<public type="default">
    <decl_stmt><decl><type><name>int</name></type> <name>svar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>uvar</name></decl>;</decl_stmt>
</public>}</block> <decl><name>number</name></decl>;</union>
```


## enum Declaration
### Element
* **&lt;enum&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
enum DAY {
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
};
```
```XML
<enum>enum <name>DAY</name> <block>{
    <decl><name>sunday</name> <init>= <expr><lit:literal type="number">0</lit:literal></expr></init></decl><op:operator>,</op:operator>
    <decl><name>monday</name></decl><op:operator>,</op:operator>
    <decl><name>tuesday</name></decl><op:operator>,</op:operator>
    <decl><name>wednesday</name></decl><op:operator>,</op:operator>
    <decl><name>thursday</name></decl><op:operator>,</op:operator>
    <decl><name>friday</name></decl><op:operator>,</op:operator>
    <decl><name>saturday</name></decl><op:operator>,</op:operator>
}</block>;</enum>
```


#### 2

```C++
enum DAY;
```
```XML
<enum>enum <name>DAY</name>;</enum>
```


#### 3

```C++
enum { yes, no } response;
```
```XML
<enum>enum <block>{ <decl><name>yes</name></decl><op:operator>,</op:operator> <decl><name>no</name></decl> }</block> <decl><name>response</name></decl>;</enum>
```


## Array Declaration
### Element
* **&lt;decl&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;index&gt;** 


### Examples

#### 1

```C++
char A[2];
```
```XML
<decl_stmt><decl><type><name>char</name></type> <name><name>A</name><index>[<expr><lit:literal type="number">2</lit:literal></expr>]</index></name></decl>;</decl_stmt>
```


#### 2

```C++
float matrix[10][15];
```
```XML
<decl_stmt><decl><type><name>float</name></type> <name><name>matrix</name><index>[<expr><lit:literal type="number">10</lit:literal></expr>]</index><index>[<expr><lit:literal type="number">15</lit:literal></expr>]</index></name></decl>;</decl_stmt>
```


#### 3

```C++
struct {
    float x, y;
} complex[100];
```
```XML
<struct>struct <block>{<public type="default">
    <decl_stmt><decl><type><name>float</name></type> <name>x</name></decl><op:operator>,</op:operator> <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
</public>}</block> <decl><name><name>complex</name><index>[<expr><lit:literal type="number">100</lit:literal></expr>]</index></name></decl>;</struct>
```


#### 4

```C++
extern char *name[];
```
```XML
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <type:modifier>*</type:modifier></type><name><name>name</name><index>[]</index></name></decl>;</decl_stmt>
```


## Array Declaration Initialization
### Element
* **&lt;init&gt;** 

### SubElement
* **&lt;block&gt;** 


### Examples

#### 1

```C++
int myArray[10] = { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 };
```
```XML
<decl_stmt><decl><type><name>int</name></type> <name><name>myArray</name><index>[<expr><lit:literal type="number">10</lit:literal></expr>]</index></name> <init>= <expr><block>{ <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr>, <expr><lit:literal type="number">5</lit:literal></expr> }</block></expr></init></decl>;</decl_stmt>
```


#### 2

```C++
int a[6] = { [4] = 29, [2] = 15 };
```
```XML
<decl_stmt><decl><type><name>int</name></type> <name><name>a</name><index>[<expr><lit:literal type="number">6</lit:literal></expr>]</index></name> <init>= <expr><block>{ <expr><index>[<expr><lit:literal type="number">4</lit:literal></expr>]</index> <op:operator>=</op:operator> <lit:literal type="number">29</lit:literal></expr>, <expr><index>[<expr><lit:literal type="number">2</lit:literal></expr>]</index> <op:operator>=</op:operator> <lit:literal type="number">15</lit:literal></expr> }</block></expr></init></decl>;</decl_stmt>
```


## Pointer Declaration
### Element
* **&lt;type:modifier&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --modifier


### Examples

#### 1

```C++
char *message;
```
```XML
<decl_stmt><decl><type><name>char</name> <type:modifier>*</type:modifier></type><name>message</name></decl>;</decl_stmt>
```


#### 2

```C++
int *pointers[10];
```
```XML
<decl_stmt><decl><type><name>int</name> <type:modifier>*</type:modifier></type><name><name>pointers</name><index>[<expr><lit:literal type="number">10</lit:literal></expr>]</index></name></decl>;</decl_stmt>
```


#### 3

```C++
int (*pointer)[10];
```
```XML
<expr_stmt><expr><call><name>int</name> <argument_list>(<argument><expr><op:operator>*</op:operator><name>pointer</name></expr></argument>)</argument_list></call><index>[<expr><lit:literal type="number">10</lit:literal></expr>]</index></expr>;</expr_stmt>
```


#### 4

```C++
int const *x;
```
```XML
<decl_stmt><decl><type><name>int</name> <specifier>const</specifier> <type:modifier>*</type:modifier></type><name>x</name></decl>;</decl_stmt>
```


#### 5

```C++
int(*X)(void);
int(*X)(int, float);
int(*X)(char const*,...);
```
```XML
<function_decl><type><name>int</name></type>(<type:modifier>*</type:modifier><name>X</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<type:modifier>*</type:modifier><name>X</name>)<parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>float</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>(<type:modifier>*</type:modifier><name>X</name>)<parameter_list>(<param><decl><type><name>char</name> <specifier>const</specifier><type:modifier>*</type:modifier></type></decl></param>,<param><decl><type><type:modifier>...</type:modifier></type></decl></param>)</parameter_list>;</function_decl>
```


#### 6

```C++
int volatile *const z = &some_object;
```
```XML
<decl_stmt><decl><type><name>int</name> <specifier>volatile</specifier> <type:modifier>*</type:modifier><specifier>const</specifier></type> <name>z</name> <init>= <expr><op:operator>&amp;</op:operator><name>some_object</name></expr></init></decl>;</decl_stmt>
```


#### 7

```C++
int *const volatile w = &some_object;
```
```XML
<decl_stmt><decl><type><name>int</name> <type:modifier>*</type:modifier><specifier>const</specifier> <specifier>volatile</specifier></type> <name>w</name> <init>= <expr><op:operator>&amp;</op:operator><name>some_object</name></expr></init></decl>;</decl_stmt>
```


## Function Declaration
### Element
* **&lt;function_decl&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;param&gt;** 


### Examples

#### 1

```C++
struct STUDENT sortstu( STUDENT a, STUDENT b );
void print(STUDENT a);
```
```XML
<function_decl><type>struct <name>STUDENT</name></type> <name>sortstu</name><parameter_list>( <param><decl><type><name>STUDENT</name></type> <name>a</name></decl></param>, <param><decl><type><name>STUDENT</name></type> <name>b</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>print</name><parameter_list>(<param><decl><type><name>STUDENT</name></type> <name>a</name></decl></param>)</parameter_list>;</function_decl>
```


#### 2

```C++
void foo (int a[]);
```
```XML
<function_decl><type><name>void</name></type> <name>foo</name> <parameter_list>(<param><decl><type><name>int</name></type> <name><name>a</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
```


#### 3

```C++
void foo (int* a);
```
```XML
<function_decl><type><name>void</name></type> <name>foo</name> <parameter_list>(<param><decl><type><name>int</name><type:modifier>*</type:modifier></type> <name>a</name></decl></param>)</parameter_list>;</function_decl>
```


#### 4

```C++
int add_multiple_values (int number, ...);
```
```XML
<function_decl><type><name>int</name></type> <name>add_multiple_values</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>number</name></decl></param>, <param><decl><type><type:modifier>...</type:modifier></type></decl></param>)</parameter_list>;</function_decl>
```


#### 5

```C++
int func(a, b, c)
   int a;
   int b;
   int c;
{ }
```
```XML
<function_decl><type><name>int</name></type> <name>func</name><parameter_list>(<param><decl><type><name>a</name></type></decl></param>, <param><decl><type><name>b</name></type></decl></param>, <param><decl><type><name>c</name></type></decl></param>)</parameter_list>
   <decl_stmt><decl><type><name>int</name></type> <name>a</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<block>{ }</block></function_decl>
```


#### 6

```C++
auto temp() -> int;
```
```XML
<function_decl><type><name>auto</name></type> <name>temp</name><parameter_list>()</parameter_list> -&gt; <type><name>int</name></type>;</function_decl>
```


## Function Definition
### Element
* **&lt;function&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;param&gt;** 


### Examples

#### 1

```C++
struct STUDENT sortstu( STUDENT a, STUDENT b ) {
    struct STUDENT x;
    return x;
}
```
```XML
<function><type>struct <name>STUDENT</name></type> <name>sortstu</name><parameter_list>( <param><decl><type><name>STUDENT</name></type> <name>a</name></decl></param>, <param><decl><type><name>STUDENT</name></type> <name>b</name></decl></param> )</parameter_list> <block>{
    <decl_stmt><decl><type>struct <name>STUDENT</name></type> <name>x</name></decl>;</decl_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block></function>
```


#### 2

```C++
void print(STUDENT a) { }
```
```XML
<function><type><name>void</name></type> <name>print</name><parameter_list>(<param><decl><type><name>STUDENT</name></type> <name>a</name></decl></param>)</parameter_list> <block>{ }</block></function>
```


#### 3

```C++
void foo (int a[]) { } 
```
```XML
<function><type><name>void</name></type> <name>foo</name> <parameter_list>(<param><decl><type><name>int</name></type> <name><name>a</name><index>[]</index></name></decl></param>)</parameter_list> <block>{ }</block></function> 
```


#### 4

```C++
void foo (int* a) { }
```
```XML
<function><type><name>void</name></type> <name>foo</name> <parameter_list>(<param><decl><type><name>int</name><type:modifier>*</type:modifier></type> <name>a</name></decl></param>)</parameter_list> <block>{ }</block></function>
```


#### 5

```C++
int add_multiple_values (int number, ...) { }
```
```XML
<function><type><name>int</name></type> <name>add_multiple_values</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>number</name></decl></param>, <param><decl><type><type:modifier>...</type:modifier></type></decl></param>)</parameter_list> <block>{ }</block></function>
```


#### 6

```C++
auto temp() -> int { }
```
```XML
<function><type><name>auto</name></type> <name>temp</name><parameter_list>()</parameter_list> -&gt; <type><name>int</name></type> <block>{ }</block></function>
```


## Function Call
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
foo(x, y, z);
```
```XML
<expr_stmt><expr><call><name>foo</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## break
### Element
* **&lt;break&gt;** 


### Example

```C++
char c;
for(;;) {
    printf_s( "\nPress any key, Q to quit: " );

    // Convert to character value
    scanf_s("%c", &c);
    if (c == 'Q')
        break;
}
```
```XML
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<for>for(<init>;</init><condition>;</condition><incr/>) <block>{
    <expr_stmt><expr><call><name>printf_s</name><argument_list>( <argument><expr><lit:literal type="string">&quot;\nPress any key, Q to quit: &quot;</lit:literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Convert to character value</comment>
    <expr_stmt><expr><call><name>scanf_s</name><argument_list>(<argument><expr><lit:literal type="string">&quot;%c&quot;</lit:literal></expr></argument>, <argument><expr><op:operator>&amp;</op:operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>c</name> <op:operator>==</op:operator> <lit:literal type="char">'Q'</lit:literal></expr>)</condition><then>
        <break>break;</break></then></if>
}</block></for>
```


## Block
### Element
* **&lt;block&gt;** 


### Example

```C++
 {
    line[i] = x;
    x++;
    i--;
}
```
```XML
 <block>{
    <expr_stmt><expr><name><name>line</name><index>[<expr><name>i</name></expr>]</index></name> <op:operator>=</op:operator> <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name><op:operator>++</op:operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><op:operator>--</op:operator></expr>;</expr_stmt>
}</block>
```


## continue Statement
### Element
* **&lt;continue&gt;** 


### Example

```C++
while ( i-- > 0 ) 
{
    x = f( i );
    if ( x == 1 ) {
        continue;
    }
    y += x * x;
}
```
```XML
<while>while <condition>( <expr><name>i</name><op:operator>--</op:operator> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition> 
<block>{
    <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <call><name>f</name><argument_list>( <argument><expr><name>i</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>( <expr><name>x</name> <op:operator>==</op:operator> <lit:literal type="number">1</lit:literal></expr> )</condition><then> <block>{
        <continue>continue;</continue>
    }</block></then></if>
    <expr_stmt><expr><name>y</name> <op:operator>+=</op:operator> <name>x</name> <op:operator>*</op:operator> <name>x</name></expr>;</expr_stmt>
}</block></while>
```


## do while Statement
### Element
* **&lt;do&gt;** 

### SubElements
* **&lt;block&gt;** 
* **&lt;condition&gt;** 


### Examples

#### 1

```C++
do {
    y = f( x );
    x--;
} while ( x > 0 );
```
```XML
<do>do <block>{
    <expr_stmt><expr><name>y</name> <op:operator>=</op:operator> <call><name>f</name><argument_list>( <argument><expr><name>x</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>x</name><op:operator>--</op:operator></expr>;</expr_stmt>
}</block> while <condition>( <expr><name>x</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition>;</do>
```


#### 2

```C++
do x--; while ( x > 0 );

```
```XML
<do>do <expr_stmt><expr><name>x</name><op:operator>--</op:operator></expr>;</expr_stmt> while <condition>( <expr><name>x</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition>;</do>

```


## for Statement
### Element
* **&lt;for&gt;** 

### SubElements
* **&lt;init&gt;** 
* **&lt;condition&gt;** 
* **&lt;incr&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
for( ;; ) { }
```
```XML
<for>for( <init>;</init><condition>;</condition> <incr/>) <block>{ }</block></for>
```


#### 2

```C++
for (i = 0; i < max; i++ ) 
{
  if ( line[i] == ' ' )
  {
      space++;
  }
  if ( line[i] == '\t' )
  {
      tab++;
  }
}
```
```XML
<for>for (<init><expr><name>i</name> <op:operator>=</op:operator> <lit:literal type="number">0</lit:literal></expr>;</init> <condition><expr><name>i</name> <op:operator>&lt;</op:operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><op:operator>++</op:operator></expr></incr> ) 
<block>{
  <if>if <condition>( <expr><name><name>line</name><index>[<expr><name>i</name></expr>]</index></name> <op:operator>==</op:operator> <lit:literal type="char">' '</lit:literal></expr> )</condition><then>
  <block>{
      <expr_stmt><expr><name>space</name><op:operator>++</op:operator></expr>;</expr_stmt>
  }</block></then></if>
  <if>if <condition>( <expr><name><name>line</name><index>[<expr><name>i</name></expr>]</index></name> <op:operator>==</op:operator> <lit:literal type="char">'\t'</lit:literal></expr> )</condition><then>
  <block>{
      <expr_stmt><expr><name>tab</name><op:operator>++</op:operator></expr>;</expr_stmt>
  }</block></then></if>
}</block></for>
```


#### 3

```C++
for(int i =0; i < 10;++i)
	a += x[i];
```
```XML
<for>for(<init><decl><type><name>int</name></type> <name>i</name> <init>=<expr><lit:literal type="number">0</lit:literal></expr></init></decl>;</init> <condition><expr><name>i</name> <op:operator>&lt;</op:operator> <lit:literal type="number">10</lit:literal></expr>;</condition><incr><expr><op:operator>++</op:operator><name>i</name></expr></incr>)
	<expr_stmt><expr><name>a</name> <op:operator>+=</op:operator> <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
```


#### 4

```C++
for (int i : v)
    std::cout << i << ' ';
```
```XML
<for>for (<init><decl><type><name>int</name></type> <name>i</name> <range>: <expr><name>v</name></expr></range></decl></init>)
    <expr_stmt><expr><name><name>std</name><op:operator>::</op:operator><name>cout</name></name> <op:operator>&lt;&lt;</op:operator> <name>i</name> <op:operator>&lt;&lt;</op:operator> <lit:literal type="char">' '</lit:literal></expr>;</expr_stmt></for>
```


## goto Statement
### Element
* **&lt;goto&gt;** 

### SubElement
* **&lt;name&gt;** 


### Example

```C++
goto stop;
```
```XML
<goto>goto <name>stop</name>;</goto>
```


## Label Statement
### Element
* **&lt;label&gt;** 

### SubElement
* **&lt;name&gt;** 


### Example

```C++
stop:
```
```XML
<label><name>stop</name>:</label>
```


## if Statement
### Element
* **&lt;if&gt;** 

### SubElements
* **&lt;else&gt;** 
* **&lt;elseif&gt;** 
* **&lt;condition&gt;** 
* **&lt;block&gt;** 
* **&lt;then&gt;** 


### Examples

#### 1

```C++
if(x > 5)
	y+=4
```
```XML
<if>if<condition>(<expr><name>x</name> <op:operator>&gt;</op:operator> <lit:literal type="number">5</lit:literal></expr>)</condition><then>
	<expr_stmt><expr><name>y</name><op:operator>+=</op:operator><lit:literal type="number">4</lit:literal></expr></expr_stmt></then></if>
```


#### 2

```C++
if ( i > 0 ) {
    y = x / i;
}

```
```XML
<if>if <condition>( <expr><name>i</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition><then> <block>{
    <expr_stmt><expr><name>y</name> <op:operator>=</op:operator> <name>x</name> <op:operator>/</op:operator> <name>i</name></expr>;</expr_stmt>
}</block></then></if>

```


#### 3

```C++
if ( i > 0 )
    y = x / i;
else 
{
    x = i;
    y = f( x );
}
```
```XML
<if>if <condition>( <expr><name>i</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition><then>
    <expr_stmt><expr><name>y</name> <op:operator>=</op:operator> <name>x</name> <op:operator>/</op:operator> <name>i</name></expr>;</expr_stmt></then>
<else>else 
<block>{
    <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y</name> <op:operator>=</op:operator> <call><name>f</name><argument_list>( <argument><expr><name>x</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
```


#### 4

```C++
if ( i > 0 )           /* Without braces */
    if ( j > i )
        x = j;
    else
        x = i;
```
```XML
<if>if <condition>( <expr><name>i</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition><then>           <comment type="block">/* Without braces */</comment>
    <if>if <condition>( <expr><name>j</name> <op:operator>&gt;</op:operator> <name>i</name></expr> )</condition><then>
        <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>j</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>i</name></expr>;</expr_stmt></else></if></then></if>
```


#### 5

```C++
if ( i > 0 ) 
{                      /* With braces */
    if ( j > i )
        x = j;
}
else
    x = i;
```
```XML
<if>if <condition>( <expr><name>i</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition><then> 
<block>{                      <comment type="block">/* With braces */</comment>
    <if>if <condition>( <expr><name>j</name> <op:operator>&gt;</op:operator> <name>i</name></expr> )</condition><then>
        <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>j</name></expr>;</expr_stmt></then></if>
}</block></then>
<else>else
    <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>i</name></expr>;</expr_stmt></else></if>
```


#### 6

```C++
if ( i > 0 ) 
{
 	x = i;   
}
else if( i < 0)
	x = q;
else 
    x = j;
    
```
```XML
<if>if <condition>( <expr><name>i</name> <op:operator>&gt;</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition><then> 
<block>{
 	<expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>i</name></expr>;</expr_stmt>   
}</block></then>
<elseif>else <if>if<condition>( <expr><name>i</name> <op:operator>&lt;</op:operator> <lit:literal type="number">0</lit:literal></expr>)</condition><then>
	<expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>q</name></expr>;</expr_stmt></then></if></elseif>
<else>else 
    <expr_stmt><expr><name>x</name> <op:operator>=</op:operator> <name>j</name></expr>;</expr_stmt></else></if>
    
```


## Empty Statement
### Element
* **&lt;empty_stmt&gt;** 


### Example

```C++
;
```
```XML
<empty_stmt>;</empty_stmt>
```


## return
### Element
* **&lt;return&gt;** 


### Examples

#### 1

```C++
return( s * (long long)s );
```
```XML
<return>return<expr><op:operator>(</op:operator> <name>s</name> <op:operator>*</op:operator> <op:operator>(</op:operator><name>long</name> <name>long</name><op:operator>)</op:operator><name>s</name> <op:operator>)</op:operator></expr>;</return>
```


#### 2

```C++
return;
```
```XML
<return>return;</return>
```


## switch Statements
### Element
* **&lt;switch&gt;** 

### SubElements
* **&lt;case&gt;** 
* **&lt;condition&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
switch( c ) 
{
    case 'A':
        capa++;
    case 'a':
        lettera++;
    default :
        total++;
}
```
```XML
<switch>switch<condition>( <expr><name>c</name></expr> )</condition> 
<block>{
    <case>case <expr><lit:literal type="char">'A'</lit:literal></expr>:
        <expr_stmt><expr><name>capa</name><op:operator>++</op:operator></expr>;</expr_stmt>
    </case><case>case <expr><lit:literal type="char">'a'</lit:literal></expr>:
        <expr_stmt><expr><name>lettera</name><op:operator>++</op:operator></expr>;</expr_stmt>
    </case><default>default :
        <expr_stmt><expr><name>total</name><op:operator>++</op:operator></expr>;</expr_stmt>
</default>}</block></switch>
```


#### 2

```C++
switch( i ) 
{
    case -1:
        n++;
        break;
    case 0 :
        z++;
        break;
    case 1 :
        p++;
        break;
}
```
```XML
<switch>switch<condition>( <expr><name>i</name></expr> )</condition> 
<block>{
    <case>case <expr><op:operator>-</op:operator><lit:literal type="number">1</lit:literal></expr>:
        <expr_stmt><expr><name>n</name><op:operator>++</op:operator></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><lit:literal type="number">0</lit:literal></expr> :
        <expr_stmt><expr><name>z</name><op:operator>++</op:operator></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><lit:literal type="number">1</lit:literal></expr> :
        <expr_stmt><expr><name>p</name><op:operator>++</op:operator></expr>;</expr_stmt>
        <break>break;</break>
</case>}</block></switch>
```


## case Statements
### Element
* **&lt;case&gt;** 

### SubElement
* **&lt;expr&gt;** 


### Example

```C++
case THREE:
```
```XML
<case>case <expr><name>THREE</name></expr>:</case>
```


## while Statement
### Element
* **&lt;while&gt;** 

### SubElements
* **&lt;condition&gt;** 
* **&lt;block&gt;** 


### Example

```C++
while ( i >= 0 ) 
{
    string1[i] = string2[i];
    i--;
}

```
```XML
<while>while <condition>( <expr><name>i</name> <op:operator>&gt;=</op:operator> <lit:literal type="number">0</lit:literal></expr> )</condition> 
<block>{
    <expr_stmt><expr><name><name>string1</name><index>[<expr><name>i</name></expr>]</index></name> <op:operator>=</op:operator> <name><name>string2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><op:operator>--</op:operator></expr>;</expr_stmt>
}</block></while>

```


## new
### Element
* **&lt;op:operator&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --operator


### Examples

#### Regular new

```C++
new foo();
```
```XML
<expr_stmt><expr><op:operator>new</op:operator> <call><name>foo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
```


#### Array new 1

```C++
new foo[5];
```
```XML
<expr_stmt><expr><op:operator>new</op:operator> <name><name>foo</name><index>[<expr><lit:literal type="number">5</lit:literal></expr>]</index></name></expr>;</expr_stmt>
```


#### Array new 2

```C++
new foo[5]();
```
```XML
<expr_stmt><expr><op:operator>new</op:operator> <name><name>foo</name><index>[<expr><lit:literal type="number">5</lit:literal></expr>]</index></name><op:operator>(</op:operator><op:operator>)</op:operator></expr>;</expr_stmt>
```


#### std::nothrow new

```C++
new (std::nothrow) char [50000000];
```
```XML
<expr_stmt><expr><op:operator>new</op:operator> <op:operator>(</op:operator><name><name>std</name><op:operator>::</op:operator><name>nothrow</name></name><op:operator>)</op:operator> <name><name>char</name> <index>[<expr><lit:literal type="number">50000000</lit:literal></expr>]</index></name></expr>;</expr_stmt>
```


#### Placement new

```C++
new (place) int;
```
```XML
<expr_stmt><expr><op:operator>new</op:operator> <op:operator>(</op:operator><name>place</name><op:operator>)</op:operator> <name>int</name></expr>;</expr_stmt>
```


## Reference Declaration
### Element
* **&lt;type:modifier&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --modifier


### Example

```C++
int& x;
```
```XML
<decl_stmt><decl><type><name>int</name><type:modifier>&amp;</type:modifier></type> <name>x</name></decl>;</decl_stmt>
```


## static_cast
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
static_cast<node*>(ptr);
```
```XML
<expr_stmt><expr><call><name><name>static_cast</name><argument_list>&lt;<argument><expr><name>node</name><op:operator>*</op:operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## dynamic_cast
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
dynamic_cast<Square*>(boxPtr);
```
```XML
<expr_stmt><expr><call><name><name>dynamic_cast</name><argument_list>&lt;<argument><expr><name>Square</name><op:operator>*</op:operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>boxPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## reinterpret_cast
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
reinterpret_cast<double>(number);
```
```XML
<expr_stmt><expr><call><name><name>reinterpret_cast</name><argument_list>&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## delete
### Element
* **&lt;op:operator&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --operator


### Examples

#### Regular delete

```C++
delete x;
```
```XML
<expr_stmt><expr><op:operator>delete</op:operator> <name>x</name></expr>;</expr_stmt>
```


#### Array delete

```C++
delete [] x;
```
```XML
<expr_stmt><expr><op:operator>delete</op:operator> <index>[]</index> <name>x</name></expr>;</expr_stmt>
```


## typeid
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
typeid(x);
```
```XML
<expr_stmt><expr><call><name>typeid</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## noexcept
### Element
* **&lt;noexcept&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Examples

#### 1

```C++
noexcept (foo(x));
```
```XML
<expr_stmt><expr><noexcept>noexcept <argument_list>(<argument><expr><call><name>foo</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></noexcept></expr>;</expr_stmt>
```


#### 2

```C++
void no_throw() noexcept { }
```
```XML
<function><type><name>void</name></type> <name>no_throw</name><parameter_list>()</parameter_list> <noexcept>noexcept</noexcept> <block>{ }</block></function>
```


## alignof
### Element
* **&lt;alignof&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
alignof(T);
```
```XML
<expr_stmt><expr><alignof>alignof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></alignof></expr>;</expr_stmt>
```


## constexpr
### Element
* **&lt;specifier&gt;** 


### Examples

#### 1

```C++
constexpr const int* xp = addr(x);
```
```XML
<decl_stmt><decl><type><specifier>constexpr</specifier> <specifier>const</specifier> <name>int</name><type:modifier>*</type:modifier></type> <name>xp</name> <init>= <expr><call><name>addr</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
```


#### 2

```C++
constexpr const int* addr(const int& ir) { return &ir; }
```
```XML
<function><type><specifier>constexpr</specifier> <specifier>const</specifier> <name>int</name><type:modifier>*</type:modifier></type> <name>addr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>int</name><type:modifier>&amp;</type:modifier></type> <name>ir</name></decl></param>)</parameter_list> <block>{ <return>return <expr><op:operator>&amp;</op:operator><name>ir</name></expr>;</return> }</block></function>
```


## alignas
### Element
* **&lt;alignas&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
alignas(MyType);
```
```XML
<decl_stmt><decl><type><alignas>alignas<argument_list>(<argument><expr><name>MyType</name></expr></argument>)</argument_list></alignas></type></decl>;</decl_stmt>
```


## namespace
### Element
* **&lt;namespace&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
namespace ns { }
```
```XML
<namespace>namespace <name>ns</name> <block>{ }</block></namespace>
```


#### 2

```C++
inline namespace ns { }
```
```XML
<namespace><specifier>inline</specifier> namespace <name>ns</name> <block>{ }</block></namespace>
```


#### 3

```C++
namespace ns;
```
```XML
<namespace>namespace <name>ns</name>;</namespace>
```


#### 4

```C++
using namespace ns;
```
```XML
<using>using namespace <name>ns</name>;</using>
```


#### 5

```C++
namespace new_name = ns; 
```
```XML
<namespace>namespace <name>new_name</name> = <name>ns</name>;</namespace> 
```


#### 6

```C++
namespace { }
```
```XML
<namespace>namespace <block>{ }</block></namespace>
```


## thread_local
### Element
* **&lt;specifier&gt;** 


### Example

```C++
thread_local int i;
```
```XML
<decl_stmt><decl><type><specifier>thread_local</specifier> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
```


## decltype
### Element
* **&lt;decltype&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Examples

#### 1

```C++
decltype(int) i;
```
```XML
<decl_stmt><decl><type><decltype>decltype<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></decltype></type> <name>i</name></decl>;</decl_stmt>
```


#### 2

```C++
decltype(int)
```
```XML
decltype<expr_stmt><expr><op:operator>(</op:operator><name>int</name><op:operator>)</op:operator></expr></expr_stmt>
```


## Type Aliasing
### Element
* **&lt;using&gt;** 


### Example

```C++
template<class T> using Vec = vector<T, Alloc<T>>;
```
```XML
<using><template>template<parameter_list>&lt;<param><type><name>class</name></type> <name>T</name></param>&gt;</parameter_list></template> using <name>Vec</name> <init>= <type><expr><name><name>vector</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name><name>Alloc</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></type></init>;</using>
```


## Attribute
### Element
* **&lt;attribute&gt;** 

### SubElement
* **&lt;expr&gt;** 


### Example

```C++
[[noreturn]] void std::exit() { }
```
```XML
<function><type><attribute>[[<expr><name>noreturn</name></expr>]]</attribute> <name>void</name></type> <name><name>std</name><op:operator>::</op:operator><name>exit</name></name><parameter_list>()</parameter_list> <block>{ }</block></function>
```


## Initialization with an initialization_list
### Element
* **&lt;call&gt;** 

### SubElement
* **&lt;block&gt;** 


### Example

```C++
T x{ arg };
```
```XML
<decl_stmt><decl><type><name>T</name></type> <name>x</name><argument_list>{ <argument><expr><name>arg</name></expr></argument> }</argument_list></decl>;</decl_stmt>
```


## Default Function Arguments
### Element
* **&lt;init&gt;** 

### SubElement
* **&lt;expr&gt;** 


### Example

```C++
void point(int x = 3, int y = 4);
```
```XML
<function_decl><type><name>void</name></type> <name>point</name><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name> <init>= <expr><lit:literal type="number">3</lit:literal></expr></init></decl></param>, <name>int</name> <name>y</name> <op:operator>=</op:operator> <lit:literal type="number">4</lit:literal>)</parameter_list>;</function_decl>
```


## RValue Reference
### Element
* **&lt;type:modifier&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --modifier


### Example

```C++
int&& x;
```
```XML
<decl_stmt><decl><type><name>int</name><type:modifier>&amp;&amp;</type:modifier></type> <name>x</name></decl>;</decl_stmt>
```


## Lamda Expression
### Element
* **&lt;lambda&gt;** 

### SubElements
* **&lt;parameter_list&gt;** 
* **&lt;param&gt;** 
* **&lt;capture&gt;** 
* **&lt;argument&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
[](int x) { return 0;} 
```
```XML
<expr_stmt><expr><lambda><capture>[]</capture><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list> <block>{ <return>return <expr><lit:literal type="number">0</lit:literal></expr>;</return>}</block></lambda></expr></expr_stmt> 
```


#### 2

```C++
[] { return 0; } 
```
```XML
<expr_stmt><expr><lambda><capture>[]</capture> <block>{ <return>return <expr><lit:literal type="number">0</lit:literal></expr>;</return> }</block></lambda></expr></expr_stmt> 
```


#### 3

```C++
[](int x) -> int { return 0;} 
```
```XML
<expr_stmt><expr><lambda><capture>[]</capture><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list> -&gt; <type><name>int</name></type> <block>{ <return>return <expr><lit:literal type="number">0</lit:literal></expr>;</return>}</block></lambda></expr></expr_stmt> 
```


#### 4

```C++
[i](int x) { return i; } 
```
```XML
<expr_stmt><expr><lambda><capture>[<argument><name>i</name></argument>]</capture><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name>i</name></expr>;</return> }</block></lambda></expr></expr_stmt> 
```


#### 5

```C++
[=](int x) { return 0;} 
```
```XML
<expr_stmt><expr><lambda><capture>[<argument><type:modifier>=</type:modifier></argument>]</capture><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list> <block>{ <return>return <expr><lit:literal type="number">0</lit:literal></expr>;</return>}</block></lambda></expr></expr_stmt> 
```


#### 6

```C++
[&](int x) { return 0;} 
```
```XML
<expr_stmt><expr><lambda><capture>[<argument><type:modifier>&amp;</type:modifier></argument>]</capture><parameter_list>(<param><decl><type><name>int</name></type> <name>x</name></decl></param>)</parameter_list> <block>{ <return>return <expr><lit:literal type="number">0</lit:literal></expr>;</return>}</block></lambda></expr></expr_stmt> 
```


#### 7

```C++
[=](int const& x) mutable { return 0;} 
```
```XML
<expr_stmt><expr><lambda><capture>[<argument><type:modifier>=</type:modifier></argument>]</capture><parameter_list>(<param><decl><type><name>int</name> <specifier>const</specifier><type:modifier>&amp;</type:modifier></type> <name>x</name></decl></param>)</parameter_list> <specifier>mutable</specifier> <block>{ <return>return <expr><lit:literal type="number">0</lit:literal></expr>;</return>}</block></lambda></expr></expr_stmt> 
```


## throw
### Element
* **&lt;throw&gt;** 

### SubElement
* **&lt;expr&gt;** 


### Examples

#### 1

```C++
throw;
```
```XML
<throw>throw;</throw>
```


#### 2

```C++
throw std::runtime_error("msg");
```
```XML
<throw>throw <expr><call><name><name>std</name><op:operator>::</op:operator><name>runtime_error</name></name><argument_list>(<argument><expr><lit:literal type="string">&quot;msg&quot;</lit:literal></expr></argument>)</argument_list></call></expr>;</throw>
```


#### 3

```C++
void f() throw(X, Y);
```
```XML
<function_decl><type><name>void</name></type> <name>f</name><parameter_list>()</parameter_list> <throw>throw<argument_list>(<argument><expr><name>X</name></expr></argument>, <argument><expr><name>Y</name></expr></argument>)</argument_list></throw>;</function_decl>
```


## try
### Element
* **&lt;try&gt;** 

### SubElements
* **&lt;block&gt;** 
* **&lt;catch&gt;** 


### Example

```C++
try {

}
```
```XML
<try>try <block>{

}</block></try>
```


## catch
### Element
* **&lt;catch&gt;** 

### SubElements
* **&lt;parameter_list&gt;** 
* **&lt;param&gt;** 


### Examples

#### 1

```C++
try {
	
} catch(const std::exception& e) {
	
}
```
```XML
<try>try <block>{
	
}</block> <catch>catch<parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>std</name><op:operator>::</op:operator><name>exception</name></name><type:modifier>&amp;</type:modifier></type> <name>e</name></decl></param>)</parameter_list> <block>{
	
}</block></catch></try>
```


#### 2

```C++
catch(...) {
	
}
```
```XML
<catch>catch<parameter_list>(<param><decl><type><type:modifier>...</type:modifier></type></decl></param>)</parameter_list> <block>{
	
}</block></catch>
```


## Function try-catch
### Element
* **&lt;try&gt;** 

### SubElements
* **&lt;catch&gt;** 
* **&lt;block&gt;** 
* **&lt;member_list&gt;** 


### Examples

#### 1

```C++
struct S {
    S(const std::string& arg) try : m(arg) {        
    } catch(const std::exception& e) {
    } // implicit throw; here
};
```
```XML
<struct>struct <name>S</name> <block>{<public type="default">
    <constructor><name>S</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>std</name><op:operator>::</op:operator><name>string</name></name><type:modifier>&amp;</type:modifier></type> <name>arg</name></decl></param>)</parameter_list> <try>try <member_list>: <call><name>m</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> </member_list><block>{        
    }</block> <catch>catch<parameter_list>(<param><decl><type><specifier>const</specifier> <name><name>std</name><op:operator>::</op:operator><name>exception</name></name><type:modifier>&amp;</type:modifier></type> <name>e</name></decl></param>)</parameter_list> <block>{
    }</block></catch></try></constructor> <comment type="line">// implicit throw; here</comment>
</public>}</block>;</struct>
```


#### 2

```C++
int f(int n) try {

} catch(...) {

}
```
```XML
<function><type><name>int</name></type> <name>f</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <name>try</name> <block>{

}</block></function> <catch>catch<parameter_list>(<param><decl><type><type:modifier>...</type:modifier></type></decl></param>)</parameter_list> <block>{

}</block></catch>
```


## Variadic Type Modifier
### Element
* **&lt;type:modifier&gt;** 


### Example

```C++
int x(f...);
```
```XML
<function_decl><type><name>int</name></type> <name>x</name><parameter_list>(<param><decl><type><name>f</name><type:modifier>...</type:modifier></type></decl></param>)</parameter_list>;</function_decl>
```


## final
### Element
* **&lt;specifier&gt;** 


### Examples

#### 1

```C++
virtual void foo() final;
```
```XML
<function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>foo</name><parameter_list>()</parameter_list> <specifier>final</specifier>;</function_decl>
```


#### 2

```C++
class X final { };
```
```XML
<class>class <name>X</name> <specifier>final</specifier> <block>{<private type="default"> </private>}</block>;</class>
```


## override
### Element
* **&lt;specifier&gt;** 


### Example

```C++
void foo() const override; 
```
```XML
<function_decl><type><name>void</name></type> <name>foo</name><parameter_list>()</parameter_list> <specifier>const</specifier> <specifier>override</specifier>;</function_decl> 
```


## class
### Element
* **&lt;class&gt;** 

### SubElement
* **&lt;name&gt;** 


### Examples

#### 1

```C++
class Foo { };
```
```XML
<class>class <name>Foo</name> <block>{<private type="default"> </private>}</block>;</class>
```


#### 2

```C++
class Foo;
```
```XML
<class_decl>class <name>Foo</name>;</class_decl>
```


#### 3

```C++
class Foo
	:public bar
{ };
```
```XML
<class>class <name>Foo</name>
	<super>:<specifier>public</specifier> <name>bar</name></super>
<block>{<private type="default"> </private>}</block>;</class>
```


#### 4

```C++
class Foo {
public:
protected:
private:
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
</private><public>public:
</public><protected>protected:
</protected><private>private:
</private>}</block>;</class>
```


#### 5

```C++
class Foo {
	Foo() { }
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<constructor><name>Foo</name><parameter_list>()</parameter_list> <block>{ }</block></constructor>
</private>}</block>;</class>
```


#### 6

```C++
class Foo {
	foo();
}
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<constructor_decl><name>foo</name><parameter_list>()</parameter_list>;</constructor_decl>
</private>}</block><decl/></class>
```


#### 7

```C++
class Foo {
	~Foo() { }
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<destructor><name>~<name>Foo</name></name><parameter_list>()</parameter_list> <block>{ }</block></destructor>
</private>}</block>;</class>
```


#### 8

```C++
class Foo {
	~Foo();
}
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<destructor_decl><name>~<name>Foo</name></name><parameter_list>()</parameter_list>;</destructor_decl>
</private>}</block><decl/></class>
```


## class Declaration
### Element
* **&lt;class_decl&gt;** 

### SubElement
* **&lt;name&gt;** 


### Example

```C++
class Foo;
```
```XML
<class_decl>class <name>Foo</name>;</class_decl>
```


## Constructor
### Element
* **&lt;constructor&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;param&gt;** 
* **&lt;member_list&gt;** 
* **&lt;block&gt;** 


### Examples

#### 1

```C++
class Foo{
	Foo()
		:x(5)
	{ }
};
```
```XML
<class>class <name>Foo</name><block>{<private type="default">
	<constructor><name>Foo</name><parameter_list>()</parameter_list>
		<member_list>:<call><name>x</name><argument_list>(<argument><expr><lit:literal type="number">5</lit:literal></expr></argument>)</argument_list></call>
	</member_list><block>{ }</block></constructor>
</private>}</block>;</class>
```


#### 2

```C++
Foo::Foo()
	:x(5)
{ }
```
```XML
<constructor><name><name>Foo</name><op:operator>::</op:operator><name>Foo</name></name><parameter_list>()</parameter_list>
	<member_list>:<call><name>x</name><argument_list>(<argument><expr><lit:literal type="number">5</lit:literal></expr></argument>)</argument_list></call>
</member_list><block>{ }</block></constructor>
```


## Constructor Declaration
### Element
* **&lt;constructor_decl&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;param&gt;** 
* **&lt;member_list&gt;** 
* **&lt;block&gt;** 


### Example

```C++
class Foo {
	Foo();
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<constructor_decl><name>Foo</name><parameter_list>()</parameter_list>;</constructor_decl>
</private>}</block>;</class>
```


## Destructor
### Element
* **&lt;destructor&gt;** 

### SubElement
* **&lt;name&gt;** 


### Examples

#### 1

```C++
class Foo {
	~Foo() { }
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<destructor><name>~<name>Foo</name></name><parameter_list>()</parameter_list> <block>{ }</block></destructor>
</private>}</block>;</class>
```


#### 2

```C++
Foo::~Foo() { }
```
```XML
<destructor><name><name>Foo</name><op:operator>::</op:operator>~<name>Foo</name></name><parameter_list>()</parameter_list> <block>{ }</block></destructor>
```


## Destructor Declaration
### Element
* **&lt;destructor_decl&gt;** 

### SubElement
* **&lt;name&gt;** 


### Example

```C++
class Foo {
	~Foo();
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<destructor_decl><name>~<name>Foo</name></name><parameter_list>()</parameter_list>;</destructor_decl>
</private>}</block>;</class>
```


## friend
### Element
* **&lt;specifier&gt;** 


### Example

```C++
class Matrix {
	friend Vector operator*(const Matrix&, const Vector&);
};
```
```XML
<class>class <name>Matrix</name> <block>{<private type="default">
	<function_decl><type><specifier>friend</specifier> <name>Vector</name></type> <name>operator*</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Matrix</name><type:modifier>&amp;</type:modifier></type></decl></param>, <param><decl><type><specifier>const</specifier> <name>Vector</name><type:modifier>&amp;</type:modifier></type></decl></param>)</parameter_list>;</function_decl>
</private>}</block>;</class>
```


## using
### Element
* **&lt;using&gt;** 

### SubElement
* **&lt;name&gt;** 


### Examples

#### 1

```C++
using namespace std;
```
```XML
<using>using namespace <name>std</name>;</using>
```


#### 2

```C++
using Base::reference;
```
```XML
<using>using <name><name>Base</name><op:operator>::</op:operator><name>reference</name></name>;</using>
```


## static_assert
### Element
* **&lt;call&gt;** 

### SubElements
* **&lt;argument_list&gt;** 
* **&lt;argument&gt;** 


### Example

```C++
static_assert(cond, "msg");
```
```XML
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><lit:literal type="string">&quot;msg&quot;</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
```


## virtual
### Element
* **&lt;specifier&gt;** 


### Example

```C++
virtual void dump() const;
```
```XML
<function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>dump</name><parameter_list>()</parameter_list> <specifier>const</specifier>;</function_decl>
```


## Abstract Function
### Element
* **&lt;lit:literal type="number"&gt;** 
     * **Note**: This mark up is disabled by default and is enabled using the following command line argument/s with srcML: 
        * --literal


### Example

```C++
struct Foo {
	virtual void dump() const = 0;
};
```
```XML
<struct>struct <name>Foo</name> <block>{<public type="default">
	<function_decl><type><specifier>virtual</specifier> <name>void</name></type> <name>dump</name><parameter_list>()</parameter_list> <specifier>const</specifier> = <lit:literal type="number">0</lit:literal>;</function_decl>
</public>}</block>;</struct>
```


## this
### Element
* **&lt;name&gt;** 


### Example

```C++
this->x = 5;
```
```XML
<expr_stmt><expr><name><name>this</name><op:operator>-&gt;</op:operator><name>x</name></name> <op:operator>=</op:operator> <lit:literal type="number">5</lit:literal></expr>;</expr_stmt>
```


## Deleted Function
### Element
* **&lt;specifier&gt;** 


### Example

```C++
void dump() = delete;
```
```XML
<function_decl><type><name>void</name></type> <name>dump</name><parameter_list>()</parameter_list> = <specifier>delete</specifier>;</function_decl>
```


## Default Function Implementation
### Element
* **&lt;specifier&gt;** 


### Example

```C++
class Foo {
	Foo() = default;
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
	<constructor_decl><name>Foo</name><parameter_list>()</parameter_list> = <specifier>default</specifier>;</constructor_decl>
</private>}</block>;</class>
```


## Operator Overloading Declaration
### Element
* **&lt;function_decl&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;parm&gt;** 


### Example

```C++
Foo& operator=(Foo&& );
```
```XML
<function_decl><type><name>Foo</name><type:modifier>&amp;</type:modifier></type> <name>operator=</name><parameter_list>(<param><decl><type><name>Foo</name><type:modifier>&amp;&amp;</type:modifier></type></decl></param> )</parameter_list>;</function_decl>
```


## Operator Overloading Definition
### Element
* **&lt;function&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;parm&gt;** 


### Example

```C++
bool operator==(Foo const&, Foo const& ) { }
```
```XML
<function><type><name>bool</name></type> <name>operator==</name><parameter_list>(<param><decl><type><name>Foo</name> <specifier>const</specifier><type:modifier>&amp;</type:modifier></type></decl></param>, <param><decl><type><name>Foo</name> <specifier>const</specifier><type:modifier>&amp;</type:modifier></type></decl></param> )</parameter_list> <block>{ }</block></function>
```


## Implicit Conversion Operator Definition
### Element
* **&lt;function&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;parm&gt;** 


### Example

```C++
operator Foo() const;
```
```XML
<function_decl><name>operator Foo</name><parameter_list>()</parameter_list> <specifier>const</specifier>;</function_decl>
```


## Implicit Conversion Operator Declaration
### Element
* **&lt;function&gt;** 

### SubElements
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;parm&gt;** 


### Example

```C++
operator Foo() const { return x->foo; }
```
```XML
<function><name>operator Foo</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><name><name>x</name><op:operator>-&gt;</op:operator><name>foo</name></name></expr>;</return> }</block></function>
```


## Explicit Conversion Operator Declaration
### Element
* **&lt;function_decl&gt;** 

### SubElements
* **&lt;specifier&gt;** 
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;parm&gt;** 


### Example

```C++
explicit operator int*() const;
```
```XML
<function_decl><type><specifier>explicit</specifier></type> <name>operator int*</name><parameter_list>()</parameter_list> <specifier>const</specifier>;</function_decl>
```


## Explicit Conversion Operator Definition
### Element
* **&lt;function&gt;** 

### SubElements
* **&lt;specifier&gt;** 
* **&lt;name&gt;** 
* **&lt;parameter_list&gt;** 
* **&lt;parm&gt;** 


### Example

```C++
explicit operator int*() const { return nullptr; }
```
```XML
<function><type><specifier>explicit</specifier></type> <name>operator int*</name><parameter_list>()</parameter_list> <specifier>const</specifier> <block>{ <return>return <expr><lit:literal type="null">nullptr</lit:literal></expr>;</return> }</block></function>
```


## explict
### Element
* **&lt;specifier&gt;** 


### Example

```C++
class Foo{ 
	explicit Foo(X const& x);
};
```
```XML
<class>class <name>Foo</name><block>{<private type="default"> 
	<constructor_decl><specifier>explicit</specifier> <name>Foo</name><parameter_list>(<param><decl><type><name>X</name> <specifier>const</specifier><type:modifier>&amp;</type:modifier></type> <name>x</name></decl></param>)</parameter_list>;</constructor_decl>
</private>}</block>;</class>
```


## template
### Element
* **&lt;template&gt;** 

### SubElements
* **&lt;parameter_list&gt;** 
* **&lt;parameter&gt;** 
* **&lt;typename&gt;** 


### Examples

#### Templated Class

```C++
template<typename T>
class Foo {
};
```
```XML
<class><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name></param>&gt;</parameter_list></template>
class <name>Foo</name> <block>{<private type="default">
</private>}</block>;</class>
```


#### Templated Function

```C++
template<typename T>
void swap(T& lhs, T& rhs);
```
```XML
<function_decl><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name></param>&gt;</parameter_list></template>
<type><name>void</name></type> <name>swap</name><parameter_list>(<param><decl><type><name>T</name><type:modifier>&amp;</type:modifier></type> <name>lhs</name></decl></param>, <param><decl><type><name>T</name><type:modifier>&amp;</type:modifier></type> <name>rhs</name></decl></param>)</parameter_list>;</function_decl>
```


#### Partial Template Specialization

```C++
template<typename T>
class Foo<T, void>
{

};
```
```XML
<class><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name></param>&gt;</parameter_list></template>
class <name><name>Foo</name><argument_list>&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>void</name></expr></argument>&gt;</argument_list></name>
<block>{<private type="default">

</private>}</block>;</class>
```


#### Template Member Function Template

```C++
template<typename T1>
template<typename T2>
int string<T1>::compare(const T2& s) { }
```
```XML
<function><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T1</name></param>&gt;</parameter_list></template>
<template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T2</name></param>&gt;</parameter_list></template>
<type><name>int</name></type> <name><name><name>string</name><argument_list>&lt;<argument><expr><name>T1</name></expr></argument>&gt;</argument_list></name><op:operator>::</op:operator><name>compare</name></name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>T2</name><type:modifier>&amp;</type:modifier></type> <name>s</name></decl></param>)</parameter_list> <block>{ }</block></function>
```


## template Specifier
### Element
* **&lt;specifier&gt;** 

### SubElements
* **&lt;parameter_list&gt;** 
* **&lt;parameter&gt;** 
* **&lt;typename&gt;** 


### Example

#### Template as a Specifier

```C++
typename t::template iterator<int>::value_type v;
```
```XML
<decl_stmt><decl><type><typename>typename</typename> <name><name>t</name><op:operator>::</op:operator><name><specifier>template</specifier> <name>iterator</name><argument_list>&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><op:operator>::</op:operator><name>value_type</name></name></type> <name>v</name></decl>;</decl_stmt>
```


## Template Parameters
### Element
* **&lt;parameter_list&gt;** 

### SubElement
* **&lt;param&gt;** 


### Examples

#### typename Parameter

```C++
template<typename T>
struct Foo { };
```
```XML
<struct><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name></param>&gt;</parameter_list></template>
struct <name>Foo</name> <block>{<public type="default"> </public>}</block>;</struct>
```


#### class Parameter

```C++
template<class T>
struct Foo { };
```
```XML
<struct><template>template<parameter_list>&lt;<param><type><name>class</name></type> <name>T</name></param>&gt;</parameter_list></template>
struct <name>Foo</name> <block>{<public type="default"> </public>}</block>;</struct>
```


#### Default Template Parameter

```C++
template<typename T = Bar>
class Foo { };
```
```XML
<class><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type> <name>T</name> <init>= <expr><name>Bar</name></expr></init></param>&gt;</parameter_list></template>
class <name>Foo</name> <block>{<private type="default"> </private>}</block>;</class>
```


#### Template Parameter Pack

```C++
template<class ... Types> struct Tuple {};
```
```XML
<struct><template>template<parameter_list>&lt;<param><type><name>class</name> <type:modifier>...</type:modifier></type> <name>Types</name></param>&gt;</parameter_list></template> struct <name>Tuple</name> <block>{<public type="default"/>}</block>;</struct>
```


#### Template Template Parameter

```C++
template<template<typename> class C>
class Foo { };
```
```XML
<class><template>template<parameter_list>&lt;<param><type><template>template<parameter_list>&lt;<param><type><typename>typename</typename></type></param>&gt;</parameter_list></template> <name>class</name></type> <name>C</name></param>&gt;</parameter_list></template>
class <name>Foo</name> <block>{<private type="default"> </private>}</block>;</class>
```


## enum class
### Element
* **&lt;enum&gt;** 


### Example

```C++
enum class Color {RED, GREEN, BLUE};

```
```XML
<enum>enum class <name>Color</name> <block>{<decl><name>RED</name></decl><op:operator>,</op:operator> <decl><name>GREEN</name></decl><op:operator>,</op:operator> <decl><name>BLUE</name></decl>}</block>;</enum>

```


## Default public Visibility
### Element
* **&lt;public type="default"&gt;** 


### Example

```C++
struct Foo {

};
```
```XML
<struct>struct <name>Foo</name> <block>{<public type="default">

</public>}</block>;</struct>
```


## public Visibility
### Element
* **&lt;public&gt;** 


### Example

```C++
class Foo {
public:
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
</private><public>public:
</public>}</block>;</class>
```


## Default private Visibility
### Element
* **&lt;private type="default"&gt;** 


### Example

```C++
class Foo
{
	
};
```
```XML
<class>class <name>Foo</name>
<block>{<private type="default">
	
</private>}</block>;</class>
```


## private Visibility
### Element
* **&lt;private&gt;** 


### Example

```C++
struct Foo {
private:
};
```
```XML
<struct>struct <name>Foo</name> <block>{<public type="default">
</public><private>private:
</private>}</block>;</struct>
```


## protected Visibility
### Element
* **&lt;protected&gt;** 


### Example

```C++
class Foo {
protected:
};
```
```XML
<class>class <name>Foo</name> <block>{<private type="default">
</private><protected>protected:
</protected>}</block>;</class>
```


## protected Inheritance Specifier
### Element
* **&lt;specifier&gt;** 


### Example

```C++
class Foo
	:protected Bar
{ };
```
```XML
<class>class <name>Foo</name>
	<super>:<specifier>protected</specifier> <name>Bar</name></super>
<block>{<private type="default"> </private>}</block>;</class>
```


## private Inheritance Specifier
### Element
* **&lt;specifier&gt;** 


### Example

```C++
class Foo
	:private Bar
{ };
```
```XML
<class>class <name>Foo</name>
	<super>:<specifier>private</specifier> <name>Bar</name></super>
<block>{<private type="default"> </private>}</block>;</class>
```


## public Inheritance Specifier
### Element
* **&lt;specifier&gt;** 


### Example

```C++
class Foo
	:public Bar
{ };
```
```XML
<class>class <name>Foo</name>
	<super>:<specifier>public</specifier> <name>Bar</name></super>
<block>{<private type="default"> </private>}</block>;</class>
```


## Inheritance List
### Element
* **&lt;super&gt;** 

### SubElement
* **&lt;name&gt;** 


### Example

```C++
class Foo
	:Bar1, OtherBar
{ };
```
```XML
<class>class <name>Foo</name>
	<super>:<name>Bar1</name>, <name>OtherBar</name></super>
<block>{<private type="default"> </private>}</block>;</class>
```

## Operators
Name | Operator | srcML
--- | --- | ---
Pre Increment | `++` | `<op:operator>++</op:operator>`
Post Increment | `++` | `<op:operator>++</op:operator>`
Pre Decrement | `--` | `<op:operator>--</op:operator>`
Post Decrement | `--` | `<op:operator>--</op:operator>`
Address Of | `&` | `<op:operator>&amp;</op:operator>`
Dereference | `*` | `<op:operator>*</op:operator>`
Unary Minus | `-` | `<op:operator>-</op:operator>`
Bitwise Not | `~` | `<op:operator>~</op:operator>`
Logical Not | `!` | `<op:operator>!</op:operator>`
Multiplication | `*` | `<op:operator>*</op:operator>`
Division | `/` | `<op:operator>/</op:operator>`
Modulus | `%` | `<op:operator>%</op:operator>`
Addition | `+` | `<op:operator>+</op:operator>`
Subtraction | `-` | `<op:operator>-</op:operator>`
Left Shift | `<<` | `<op:operator>&lt;&lt;</op:operator>`
Right Shift | `>>` | `<op:operator>&gt;&gt;</op:operator>`
Less Then | `<` | `<op:operator>&lt;</op:operator>`
Greater Then | `>` | `<op:operator>&gt;</op:operator>`
Less Then or Equal To | `<=` | `<op:operator>&lt;=</op:operator>`
Greater Then or Equal To | `>=` | `<op:operator>&gt;=</op:operator>`
Equals | `==` | `<op:operator>==</op:operator>`
Not Equal | `!=` | `<op:operator>!=</op:operator>`
Bitwise And | `&` | `<op:operator>&amp;</op:operator>`
Bitwise XOr | `^` | `<op:operator>^</op:operator>`
Bitwise Or | <code>&#124;</code> | <code>&lt;op:operator&gt;&#124;&lt;/op:operator&gt;</code>
Logical And | `&&` | `<op:operator>&amp;&amp;</op:operator>`
Logical Or | <code>&#124;&#124;</code> | <code>&lt;op:operator&gt;&#124;&#124;&lt;/op:operator&gt;</code>
Assignment | `=` | `<op:operator>=</op:operator>`
Multiply Assign | `*=` | `<op:operator>*=</op:operator>`
Divide Assign | `/=` | `<op:operator>/=</op:operator>`
Modulus Assign | `%=` | `<op:operator>%=</op:operator>`
Add Assign | `+=` | `<op:operator>+=</op:operator>`
Subtract Assign | `-=` | `<op:operator>-=</op:operator>`
Left Shift Assign | `<<=` | `<op:operator>&lt;&lt;=</op:operator>`
Right Shift Assign | `>>=` | `<op:operator>&gt;&gt;=</op:operator>`
Bitwise And Assign | `&=` | `<op:operator>&amp;=</op:operator>`
Bitwise XOr Assign | `^=` | `<op:operator>^=</op:operator>`
Bitwise Or Assign | <code>&#124;=</code> | <code>&lt;op:operator&gt;&#124;=&lt;/op:operator&gt;</code>
Sceope | `::` | `<op:operator>::</op:operator>`
Pointer To Member | `.*` | `<op:operator>.*</op:operator>`
Dereference Pointer To Member | `->*` | `<op:operator>-&gt;*</op:operator>`
Comma | `,` | `<op:operator>,</op:operator>`
Conditional | `?  :` | `<op:operator>?</op:operator>`<br/>`<op:operator>:</op:operator>`
Dot | `.` | `<op:operator>.</op:operator>`
Arrow | `->` | `<op:operator>-&gt;</op:operator>`

**NOTE:** Operator mark up within srcML is not enabled by default and srcML must be run with the --operator command line option to enable it.