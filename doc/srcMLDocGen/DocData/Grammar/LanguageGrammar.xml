<Grammar languageOrdering="C,C++,C#,Java">
    <Documentation>
        
        <!-- This determines overall ordering for rules within the grammar class. -->
        <Rule rule="start">
            <Desc>The start rule is the starting rule for the srcML grammar.</Desc>
        </Rule>

        <Tag elem="unit">
            <Desc>Stuff about unit.</Desc>
            <Refs>
                <See title="Main Documentation Page" url="http://www.cs.kent.edu/~bbartman/srcML/" />
            </Refs>
        </Tag>

        <AttrRule rule="dirAttr" />
        <AttrRule rule="filenameAttr" />
        <AttrRule rule="languageAttr" />
        <AttrRule rule="hashAttr" />
        <AttrRule rule="optionsAttr" />
        
        <Tag elem="macro-list" />
        <AttrRule rule="macroTokenAttr" />
        <AttrRule rule="macroTypeAttr" />

        <Tag elem="comment" />
        <AttrRule rule="commentTypeAttr" />
        <AttrRule rule="commentFormatAttr" />

        <Tag elem="escape" />
        <AttrRule rule="charAttr" />

        <Rule rule="topLevelElements">
            <Desc>All of the elements which can occur within a compilation unit.</Desc>
        </Rule>
        <Rule rule="anyCPPOrCommentOrText">
            <Desc>
                Any of the C preprocessor directives, any specially marked up
                text or a comment. Any of the child rules contained within this
                rule occur almost anywhere within a compilation unit.
            </Desc>
        </Rule>

        <!-- C preprocessor -->
        <Rule rule="cppDefine"/>
        <Tag ns="cpp" elem="define"/>
        <Tag ns="cpp" elem="directive" />
        <Tag ns="cpp" elem="macro" />
        <Tag ns="cpp" elem="number" />
        <Tag ns="cpp" elem="value" />
        <Tag ns="cpp" elem="if" />
        <Tag ns="cpp" elem="ifdef" />
        <Tag ns="cpp" elem="ifndef" />
        <Tag ns="cpp" elem="elif" />
        <Tag ns="cpp" elem="else" />
        <Tag ns="cpp" elem="endif" />
        <Tag ns="cpp" elem="region" />
        <Tag ns="cpp" elem="endregion" />
        <Tag ns="cpp" elem="error" />
        <Tag ns="cpp" elem="warning" />
        <Tag ns="cpp" elem="literal" />
        <Tag ns="cpp" elem="include" />
        <Rule rule="cppFile" />
        <Tag ns="cpp" elem="file" />
        <Rule rule="cppLine"/>
        <Tag ns="cpp" elem="line" />
        <Tag ns="cpp" elem="pragma" />
        <Tag ns="cpp" elem="undef" />
        <Tag ns="cpp" elem="empty" />
        
        
        <Tag elem="name" />
        <Tag elem="parameter_list" />
        <Tag elem="param" />
        <Tag elem="decl" />
        <Tag elem="type" />

    </Documentation>

    <!-- Grammar Rules -->
    <Rule name="start" lang="C,C++,C#,Java">
        <Def>
            <Choice>
                <Ref name="archiveUnit"/>
                <Ref name="compilationUnit"/>
            </Choice>
        </Def>
    </Rule>

    <!-- src:unit -->
    <TagRule name="archiveUnit" lang="C,C++,C#,Java" title="archive unit">
        <Desc>An archive is a collection of compilation units.</Desc>
        <Tag elem="unit">
            <Attrs>
                <Attr rule="dirAttr" isOptional="true"/>
                <Attr rule="filenameAttr" isOptional="true" />
                <Attr rule="languageAttr" isOptional="true" />
                <Attr rule="hashAttr" isOptional="true" />
                <Attr rule="optionsAttr" isOptional="true" />
            </Attrs>
        </Tag>
        <Def>
            <ZeroOrMore><Ref name="macroList"/></ZeroOrMore>
            <ZeroOrMore><Ref name="compilationUnit"/></ZeroOrMore>
        </Def>
    </TagRule>

    <TagRule name="compilationUnit" lang="C,C++,C#,Java" title="compilation unit">
        <Desc>
        </Desc>
        <Tag elem="unit">
            <Attrs>
                <Attr rule="dirAttr" isOptional="true"/>
                <Attr rule="filenameAttr" isOptional="true" />
                <Attr rule="languageAttr" isOptional="true" />
                <Attr rule="hashAttr" isOptional="true" />
                <Attr rule="optionsAttr" isOptional="true" />
            </Attrs>
        </Tag>
        <Def>
            <ZeroOrMore><Ref name="macroList"/></ZeroOrMore>
            <ZeroOrMore><Ref name="topLevelElements"/></ZeroOrMore>
        </Def>
    </TagRule>

    <AttrRule name="dirAttr" lang="C,C++,C#,Java">
        <Attr name="dir" />
        <Desc>
        The directory attribute for a unit.
        </Desc>
        <Def>
            <Text/>
        </Def>
    </AttrRule>

    <AttrRule name="languageAttr" lang="C,C++,C#,Java">
        <Attr name="language" />
        <Desc>
        The language used by srcML to create the current unit.
        </Desc>
        <Def>
            <Choice>
                <Literal value="C"/>
                <Literal value="C++"/>
                <Literal value="C#"/>
                <Literal value="Java"/>
            </Choice>
        </Def>
    </AttrRule>

    <AttrRule name="filenameAttr" lang="C,C++,C#,Java">
        <Attr name="filename" />
        <Desc>The file that was used to create the current unit.</Desc>
        <Def>
            <Text/>
        </Def>
    </AttrRule>

    <AttrRule name="hashAttr" lang="C,C++,C#,Java">
        <Attr name="hash" />
        <Desc>Not Sure.</Desc>
        <Def>
            <Text/>
        </Def>
    </AttrRule>

    <AttrRule name="optionsAttr" lang="C,C++,C#,Java">
        <Attr name="options" />
        <Desc>Not Sure.</Desc>
        <Def>
            <Text/>
        </Def>
    </AttrRule>

    
    <!-- src:macro-list -->
    <TagRule name="macroList" lang="C,C++,C#" title="macro list">
        <Desc>

        </Desc>
        <Tag elem="macro-list">
            <Attrs>
                <Attr rule="macroTokenAttr" isOptional="False"/>
                <Attr rule="macroTypeAttr" isOptional="False" />
            </Attrs>
        </Tag>
        <Def>
            <Empty />
        </Def>
    </TagRule>

    <AttrRule name="macroTokenAttr" lang="C,C++,C#">
        <Attr name="token" />
        <Desc>The element QName to mark as a macro.</Desc>
        <Def>
            <Text/>
        </Def>
    </AttrRule>

    <AttrRule name="macroTypeAttr" lang="C,C++,C#">
        <Attr name="type" />
        <Desc>The value for the token.</Desc>
        <Def>
            <Text/>
        </Def>
    </AttrRule>

    <!-- src:comment-->
    <TagRule name="comment" lang="C,C++,C#,Java" title="">
        <Tag elem="comment">
            <Attrs>
                <Attr rule="commentTypeAttr" isOptional="false" />
                <Attr rule="commentFormatAttr" isOptional="true" />
            </Attrs>
        </Tag>
        <Def>
            <Text />
        </Def>
    </TagRule>

    <AttrRule name="commentTypeAttr" lang="C,C++,C#,Java">
        <Attr name="type" />
        <Desc>The type of comment either a line comment or a block comment.</Desc>
        <Def>
            <Choice>
                <Literal value="line"/>
                <Literal value="block"/>
            </Choice>
        </Def>
    </AttrRule>

    <AttrRule name="commentFormatAttr" lang="C,C++,C#,Java">
        <Attr name="format" />
        <Desc>Indicates a possible format of a comment.</Desc>
        <Def>
            <Choice>
                <Literal value="doxygen"/>
                <Literal value="javadoc"/>
            </Choice>
        </Def>
    </AttrRule>
    
    <!-- src:escape -->
    <TagRule name="escape" lang="C,C++,C#,Java">
        <Tag elem="escape">
            <Attrs>
                <Attr rule="charAttr" isOptional="false" />
            </Attrs>
        </Tag>
        <Def>
            <Empty />
        </Def>
    </TagRule>

    <AttrRule name="charAttr" lang="C,C++,C#,Java">
        <Attr name="char" />
        <Desc>Escaped character code.</Desc>
        <Def>
            <Text />
        </Def>
    </AttrRule>
    
    
    <Rule name="topLevelElements" lang="C,C++,C#,Java">
        <Desc>All of the elements which can occur at the top level of a compilation unit.</Desc>
        <Def>
            <Choice>
                <Ref name="anyCPPOrCommentOrText"/>
                <Ref name="asm" />
                <Ref name="staticAssert" />
                <Ref name="assert" />
                <Ref name="block" />
                <Ref name="break" />
                <Ref name="case" />
                <Ref name="catch" />
                <Ref name="checkedBlock" />
                <Ref name="classInterface" />
                <Ref name="class" />
                <Ref name="classDecl" />
                <Ref name="constructorQualified" />
                <Ref name="continue" />
                <Ref name="declStmt" />
                <Ref name="defaultLabel" />
                <Ref name="destructor" />
                <Ref name="destructorDecl" />
                <Ref name="destructorQualified" />
                <Ref name="do" />
                <Ref name="else" />
                <Ref name="elseif" />
                <Ref name="emptyStmt" />
                <Ref name="exprStmt" />
                <Ref name="enum" />
                <Ref name="event" />
                <Ref name="externBlock" />
                <Ref name="finallyBlock" />
                <Ref name="fixed" />
                <Ref name="for" />
                <Ref name="forEach" />
                <Ref name="function" />
                <Ref name="functionDecl" />
                <Ref name="genericSelection" />
                <Ref name="goTo" />
                <Ref name="if" />
                <Ref name="import" />
                <Ref name="label" />
                <Ref name="linq" />
                <Ref name="lock" />
                <Ref name="namespace" />
                <Ref name="package" />
                <Ref name="private" />
                <Ref name="property" />
                <Ref name="protected" />
                <Ref name="public" />
                <Ref name="return" />
                <Ref name="staticInitializationBlock" />
                <Ref name="struct" />
                <Ref name="structDecl" />
                <Ref name="switch" />
                <Ref name="synchronized" />
                <Ref name="throw" />
                <Ref name="try" />
                <Ref name="typedef" />
                <Ref name="unchecked" />
                <Ref name="union" />
                <Ref name="unionDecl" />
                <Ref name="unsafe" />
                <Ref name="usingStmt" />
                <Ref name="usingDirective" />
                <Ref name="while" />
            </Choice>
        </Def>
    </Rule>
    
    <Rule name="anyCPPOrCommentOrText" lang="C,C++,C#,Java" title="any C preprocessor, comment or text">
        <Desc>A listing of all elements which can occur anywhere.</Desc>
        <Def>
            <Choice>
                <Ref name="cppDefine" />
                <Ref name="cppIf" />
                <Ref name="cppIfDef" />
                <Ref name="cppIfNDef" />
                <Ref name="cppElIf" />
                <Ref name="cppElse" />
                <Ref name="cppEndIf" />
                <Ref name="cppRegion" />
                <Ref name="cppEndRegion" />
                <Ref name="cppError" />
                <Ref name="cppWarning" />
                <Ref name="cppInclude" />
                <Ref name="cppLine" />
                <Ref name="cppPragma" />
                <Ref name="cppUndef" />
                <Ref name="cppEmpty" />
                <Ref name="comment" />
                <Ref name="escape" />
            </Choice>
        </Def>
    </Rule>

    <!-- cpp:directive -->
    <TagRule name="cppDirective" lang="C,C++,C#">
        <Tag ns="cpp" elem="directive"/>
        <Params>
            <Param name="value" />
        </Params>
        <Def>
            <ParamUse name="value" />
        </Def>
    </TagRule>

    <!-- cpp:define -->
    <Rule name="cppDefine" lang="C,C++,C#">
        <Def>
            <Choice>
                <Ref name="cppDefineName"/>
                <Ref name="cppDefineFunction"/>
            </Choice>
        </Def>
    </Rule>

    <TagRule name="cppDefineName" lang="C,C++,C#">
        <Tag ns="cpp" elem="define"/>
        <Def>
            <Literal value="#" />
            <Ref name="cppDirective">
                <Args>
                    <Arg><Literal value="define" /></Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="cppMacro"/>
                <Optional>
                    <Choice>
                        <Ref name="cppValue" />
                        <Ref name="cppNumber" />
                    </Choice>
                </Optional>
            </Optional>
        </Def>
    </TagRule>

    <TagRule name="cppDefineFunction" lang="C,C++">
        <Tag ns="cpp" elem="define"/>
        <Def>
            <Literal value="#" />
            <Ref name="cppDirective">
                <Args>
                    <Arg><Literal value="define" /></Arg>
                </Args>
            </Ref>
                <Ref name="cppMacroFunction"/>
                <Optional>
                    <Choice>
                        <Ref name="cppValue" />
                        <Ref name="cppNumber" />
                    </Choice>
            </Optional>
        </Def>
    </TagRule>

    <!-- cpp:macro -->
    <TagRule name="cppMacro" lang="C,C++,C#">
        <Tag ns="cpp" elem="macro"/>
        <Def>
            <Ref name="simpleName" />
        </Def>
    </TagRule>

    <TagRule name="cppMacroFunction" lang="C,C++">
        <Tag ns="cpp" elem="macro" />
        <Def>
            <Ref name="simpleName" />
            <Ref name="macroParameterList" />
        </Def>
    </TagRule>

    <!-- cpp:number -->
    <TagRule name="cppNumber" lang="C,C++,C#">
        <Tag ns="cpp" elem="number" />
        <Def>
            <Number />
        </Def>
    </TagRule>

    <!-- cpp:value -->
    <TagRule name="cppValue" lang="C,C++,C#">
        <Tag ns="cpp" elem="value" />
        <Def>
            <Text/>
        </Def>
    </TagRule>

    <!-- cpp:if -->
    <TagRule name="cppIf" lang="C,C++,C#">
        <Tag ns="cpp" elem="if" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="if" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="expr" />
            </Optional>
        </Def>
    </TagRule>

    <!-- cpp:ifdef -->
    <TagRule name="cppIfDef" lang="C,C++,C#">
        <Tag ns="cpp" elem="ifdef" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="ifdef" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="cppMacro" />
            </Optional>
        </Def>
    </TagRule>

    <!-- cpp:ifndef -->
    <TagRule name="cppIfNDef" lang="C,C++,C#">
        <Tag ns="cpp" elem="ifndef" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="ifndef" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="cppMacro" />
            </Optional>
        </Def>
    </TagRule>

    <!-- cpp:elif -->
    <TagRule name="cppElIf" lang="C,C++,C#">
        <Tag ns="cpp" elem="elif" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="elif" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="cppMacro" />
            </Optional>
        </Def>
    </TagRule>

    <!-- cpp:else -->
    <TagRule name="cppElse" lang="C,C++,C#">
        <Tag ns="cpp" elem="else" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="else" />
                    </Arg>
                </Args>
            </Ref>
        </Def>
    </TagRule>

    <!-- cpp:endif -->
    <TagRule name="cppEndIf" lang="C,C++,C#">
        <Tag ns="cpp" elem="endif" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="endif" />
                    </Arg>
                </Args>
            </Ref>
        </Def>
    </TagRule>

    <!-- cpp:region -->
    <TagRule name="cppRegion" lang="C#">
        <Tag ns="cpp" elem="region" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="region" />
                    </Arg>
                </Args>
            </Ref>
            <ZeroOrMore>
                <Choice>
                    <Ref name="simpleName" /> 
                    <Ref name="cppLiteral" />
                    <Text />
                </Choice>
            </ZeroOrMore>
        </Def>
    </TagRule>

    <!-- cpp:endregion -->
    <TagRule name="cppEndRegion" lang="C#">
        <Tag ns="cpp" elem="endregion" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="endregion" />
                    </Arg>
                </Args>
            </Ref>
        </Def>
    </TagRule>

    <!-- cpp:error -->
    <TagRule name="cppError" lang="C,C++,C#">
        <Tag ns="cpp" elem="error" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="error" />
                    </Arg>
                </Args>
            </Ref>
            <ZeroOrMore>
                <Choice>
                    <Ref name="simpleName" /> 
                    <Ref name="cppLiteral" />
                    <Text />
                </Choice>
            </ZeroOrMore>
        </Def>
    </TagRule>

    <!-- cpp:literal -->
    <TagRule name="cppLiteral" lang="C,C++,C#">
        <Tag ns="cpp" elem="literal" />
        <Def>
            <Text/>
        </Def>
    </TagRule>

    <!-- cpp:warning -->
    <TagRule name="cppWarning" lang="C,C++,C#">
        <Tag ns="cpp" elem="warning" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="warning" />
                    </Arg>
                </Args>
            </Ref>
            <ZeroOrMore>
                <Choice>
                    <Ref name="simpleName" /> 
                    <Ref name="cppLiteral" />
                    <Text />
                </Choice>
            </ZeroOrMore>
        </Def>
    </TagRule>

    <!-- cpp:include -->
    <TagRule name="cppInclude" lang="C,C++">
        <Tag ns="cpp" elem="include" />
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="include" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="cppFile" />
            </Optional>
        </Def>
    </TagRule>
    
    <!-- cpp:file -->
    <Rule name="cppFile" lang="C,C++">
        <Def>
            <Choice>
                <Ref name="cppFileSearch" />
                <Ref name="cppFileRelative" />
            </Choice>
        </Def>
    </Rule>

    <TagRule name="cppFileRelative" lang="C,C++">
        <Tag ns="cpp" elem="file"/>
        <Def>
            <Literal value="&lt;"/>
            <Text />
            <Literal value="&gt;"/>
        </Def>
    </TagRule>

    <TagRule name="cppFileSearch" lang="C,C++,C#">
        <Tag ns="cpp" elem="file"/>
        <Def>
            <Literal value="\&quot;"/>
            <Text />
            <Literal value="\&quot;"/>
        </Def>
    </TagRule>

    <!-- cpp:line -->
    <Rule name="cppLine" lang="C,C++,C#">
        <Def>
            <Choice>
                <Ref name="lineNumberAndFile" />
                <Ref name="lineHiddenOrDefault" />
            </Choice>
        </Def>
    </Rule>
    
    <TagRule name="lineNumberAndFile" lang="C,C++,C#">
        <Tag ns="cpp" elem="line"/>
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="line" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="cppNumber" />
            </Optional>
            <Optional>
                <Ref name="cppFileRelative" />
            </Optional>
        </Def>
    </TagRule>
    
    <TagRule name="lineHiddenOrDefault" lang="C#">
        <Tag ns="cpp" elem="line"/>
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="line" />
                    </Arg>
                </Args>
            </Ref>
            <Tag elem="name">
                <Choice>
                    <Literal value="hidden"/>
                    <Literal value="default"/>
                </Choice>
            </Tag>
        </Def>
    </TagRule>

    <!-- cpp:pragma -->    
    <TagRule name="cppPragma" lang="C,C++,C#">
        <Tag ns="cpp" elem="pragma"/>
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="pragma" />
                    </Arg>
                </Args>
            </Ref>
            <ZeroOrMore>
                <Choice>
                    <Ref name="simpleName" /> 
                    <Ref name="cppLiteral" />
                    <Text />
                </Choice>
            </ZeroOrMore>
        </Def>
    </TagRule>
    
    <!-- cpp:undef -->    
    <TagRule name="cppUndef" lang="C,C++,C#">
        <Tag ns="cpp" elem="undef"/>
        <Def>
            <Literal value="#"/>
            <Ref name="cppDirective">
                <Args>
                    <Arg>
                        <Literal value="pragma" />
                    </Arg>
                </Args>
            </Ref>
            <Optional>
                <Ref name="simpleName" />
            </Optional>
        </Def>
    </TagRule>
    
    <!-- cpp:empty -->    
    <TagRule name="cppEmpty" lang="C,C++,C#">
        <Tag ns="cpp" elem="empty"/>
        <Def>
            <Literal value="#"/>
        </Def>
    </TagRule>
    
    <!-- cpp:define -->
    <!-- cpp:directive -->
    <!-- cpp:elif -->
    <!-- cpp:else -->
    <!-- cpp:empty -->
    <!-- cpp:endif -->
    <!-- cpp:endregion -->
    <!-- cpp:error -->
    <!-- cpp:file -->
    <!-- cpp:if -->
    <!-- cpp:ifdef -->
    <!-- cpp:ifndef -->
    <!-- cpp:include -->
    <!-- cpp:line -->
    <!-- cpp:literal -->
    <!-- cpp:macro -->
    <!-- cpp:number -->
    <!-- cpp:pragma -->
    <!-- cpp:region -->
    <!-- cpp:undef -->
    <!-- cpp:value -->
    <!-- cpp:warning -->
    
    
    <!-- src:alignas -->
    <!-- src:alignof -->
    <!-- src:annotation -->
    <!-- src:argument -->
    <!-- src:argument_list type="template" -->
    <!-- src:argument_list -->
    <!-- src:asm -->
    <!-- src:assert type="static" -->
    <!-- src:assert -->
    <!-- src:association -->
    <!-- src:association_list -->
    <!-- src:atomic -->
    <!-- src:attribute -->
    <!-- src:block type="pseudo" -->
    <!-- src:block -->
    <!-- src:break -->
    <!-- src:by -->
    <!-- src:call -->
    <!-- src:capture -->
    <!-- src:case -->
    <!-- src:cast type="const" -->
    <!-- src:cast type="dynamic" -->
    <!-- src:cast type="reinterpret" -->
    <!-- src:cast type="static" -->
    <!-- src:catch -->
    <!-- src:checked -->
    <!-- src:class type="interface" -->
    <!-- src:class -->
    <!-- src:class_decl -->
    <!-- src:comment type="block" -->
    <!-- src:comment type="line" -->
    <!-- src:condition -->
    <!-- src:constructor -->
    <!-- src:constructor_decl -->
    <!-- src:continue -->
    <!-- src:control -->
    <!-- src:decl -->
    <!-- src:decl_stmt -->
    <!-- src:decltype -->
    <!-- src:default -->
    <!-- src:delegate -->
    <!-- src:destructor -->
    <!-- src:destructor_decl -->
    <!-- src:do -->
    <!-- src:else -->
    <!-- src:elseif -->
    <!-- src:empty_stmt -->
    <!-- src:enum type="class" -->
    <!-- src:enum -->
    <!-- src:equals -->
    <!-- src:event -->
    <!-- src:expr -->
    <!-- src:expr_stmt -->
    <!-- src:extends -->
    <!-- src:extern -->
    <!-- src:finally -->
    <!-- src:fixed -->
    <!-- src:for -->
    <!-- src:foreach -->
    <!-- src:from -->
    <!-- src:function type="operator" -->
    <!-- src:function -->
    <!-- src:function_decl type="operator" -->
    <!-- src:function_decl -->
    <!-- src:generic_selection -->
    <!-- src:goto -->
    <!-- src:group -->
    <!-- src:if -->
    <!-- src:implements -->
    <!-- src:import -->
    <!-- src:in -->
    <!-- src:incr -->
    <!-- src:index -->
    <!-- src:init -->
    <!-- src:into -->
    <!-- src:join -->
    <!-- src:label -->
    <!-- src:lambda -->
    <!-- src:let -->
    <!-- src:linq -->
    <!-- src:literal type="boolean" -->
    <!-- src:literal type="char" -->
    <!-- src:literal type="null" -->
    <!-- src:literal type="number" -->
    <!-- src:literal type="string" -->
    <!-- src:lock -->
    <!-- src:macro -->
    <!-- src:member_list -->
    <!-- src:modifier -->
    <!-- src:name -->
    <!-- src:namespace -->
    <!-- src:noexcept -->
    <!-- src:on -->
    <!-- src:operator -->
    <!-- src:orderby -->
    <!-- src:package -->
    <!-- src:param -->
    <!-- src:parameter_list type="pseudo" -->
    <!-- src:parameter_list -->
    <!-- src:private type="default" -->
    <!-- src:private -->
    <!-- src:property -->
    <!-- src:protected -->
    <!-- src:public type="default" -->
    <!-- src:public -->
    <!-- src:range -->
    <!-- src:ref_qualifier -->
    <!-- src:return -->
    <!-- src:select -->
    <!-- src:selector -->
    <!-- src:sizeof -->
    <!-- src:specifier -->
    <!-- src:static -->
    <!-- src:struct -->
    <!-- src:struct_decl -->
    <!-- src:super -->
    <!-- src:switch -->
    <!-- src:synchronized -->
    <!-- src:template -->
    <!-- src:then -->
    <!-- src:throw -->
    <!-- src:throws -->
    <!-- src:try -->
    <!-- src:type ref="prev" -->
    <!-- src:type -->
    <!-- src:typedef -->
    <!-- src:typeid -->
    <!-- src:typename -->
    <!-- src:typeof -->
    <!-- src:unchecked -->
    <!-- src:union -->
    <!-- src:union_decl -->
    <!-- src:unit -->
    <!-- src:unsafe -->
    <!-- src:using -->
    <!-- src:using_stmt -->
    <!-- src:where -->
    <!-- src:while -->
    
    <!--
    // src namespace elements
    expr '<expr>': /* TODO: Add possible expressions here!*/ ;

    // src:name
    simpleName'<name>':  Identifier ;

    Identifier: [Identifier with no spaces];

    Text: [ANYTHING];

    NUMBER     : [0-9]+ ;

    -->

    <!-- src:parameter_list -->
    <TagRule name="macroParameterList" lang="C,C++">
        <Tag elem="parameter_list"/>
        <Def>
            <Literal value="(" />
            <Optional>
                <Ref name="macroParam"/>
                <ZeroOrMore>
                    <Literal value="," />
                    <Ref name="macroParam"/>
                </ZeroOrMore>
            </Optional>
            <Literal value=")" />
        </Def>
    </TagRule>

    <!-- src:param -->
    <TagRule name="macroParam" lang="C,C++">
        <Tag elem="param"/>
        <Def>
            <Ref name="macroParamDecl"/>
        </Def>
    </TagRule>

    <!-- src:decl -->
    <TagRule name="macroParamDecl" lang="C,C++">
        <Tag elem="decl"/>
        <Def>
            <Ref name="marcoParamDeclType"/>
        </Def>
    </TagRule>

    <!-- src:type -->
    <TagRule name="marcoParamDeclType" lang="C,C++">
        <Tag elem="type"/>
        <Def>
            <Ref name="simpleName"/>
        </Def>
    </TagRule>

    <!-- src:name -->
    <TagRule name="simpleName" lang="C,C++,C#,Java">
        <Tag elem="name"/>
        <Def>
            <Identifier />
        </Def>
    </TagRule>
    <!--
        <Literal value=""/>
        <Ref name=""/>
        OR
        <Ref name="">
            <Args>
                <Arg value="Value"/>
            </Args>
        </Ref>

        <Text/>

        <ParamUse name="" />

        <Group>
        </Group>

        Names for grammar elements:
        Params
            Param
        Args
            Arg
        Optional
        ZeroOrMore
        OneOrMore
        Choice
        Ref
            @name
        Text
        Literal
        Tag ? Maybe?! Just not sure how!
    -->
</Grammar>
