default namespace = "http://www.sdml.info/srcML/src"

namespace cpp = "http://www.sdml.info/srcML/cpp"

grammar {
    start = ArchiveUnit | ArchiveUnitNoMacroList | CompilationUnit

    AnyContent = AnyElement* & text
    AnyElement = element * { AnyAttribute*, AnyContent }
    AnyAttribute = attribute * { text }

    ArchiveUnit = element  unit {
        attribute language { text }?,
        attribute filename { text }?,
        attribute dir {text}?,
        attribute hash { text }?,
        attribute options { text }?,
        MacroList*,
        CompilationUnit*
    }

    ArchiveUnitNoMacroList = element unit {
        attribute language { text }?,
        attribute filename { text }?,
        attribute dir {text}?,
        attribute hash { text }?,
        attribute options { text }?,
        CompilationUnit*
    }

    MacroList = element macro-list {
        attribute type { text },
        attribute token { text }
    }

    CompilationUnit = element unit {
        attribute language { text }?,
        attribute filename { text }?,
        attribute dir {text}?,
        attribute hash { text }?,
        attribute options { text }?,
        (MacroList | text)*,
        (AnyCPPOrComment |
        If |
        ASM |
        Assert |
        Block |
        Break |
        Case |
        CatchBlock |
        Checked |
        Interface |
        Class |
        ClassDecl |
        ConstructorQualified |
        Continue |
        DefaultLabel |
        DeclStmt |
        DestructorQualified |
        Destructor |
        DestructorDecl |
        Do |
        EmptyStmt |
        Else |
        Elseif |
        Enum |
        ExprStmt |
        ExternBlock |
        FinallyBlock |
        Fixed |
        For |
        ForEach |
        Function |
        FunctionDecl |
        GenericSelection |
        Goto |
        Import |
        Label |
        LINQ |
        Lock |
        Namespace |
        Package |
        Private |
        Protected |
        Public |
        Return |
        StaticInitBlock |
        Struct |
        StructDecl |
        Switch |
        Synchronized |
        Throw |
        Try |
        Typedef |
        UnChecked |
        Union |
        UnionDecl |
        Unsafe |
        UsingStmt |
        UsingDirective |
        While |
        Attribute |
        ConstructorDecl |
        Template |
        Lambda |
        Forever |
        Dynamic |
        text)*
    }

    # utilities 
    AnyCPPOrComment = (
        CPPDefineNamed |
        CPPDefineNoName |
        CPPElIf |
        CPPElse |
        CPPEndIf |
        CPPEndRegion |
        CPPError |
        CPPIf |
        CPPIfDef |
        CPPIfNDef |
        CPPInclude |
        CPPLine |
        CPPPragma |
        CPPRegion |
        CPPUndef |
        CPPWarning |
        Escape |
        srcMLPreprocessorErrorCase |
        Macro |
        CommentOrText)

    CommentOrText = (Comment | text | Escape)    
    
    srcMLPreprocessorErrorCase = element cpp:error {
        text
    }

    Comment = element comment {
        attribute type { "line" | string "block" },
        attribute format {"doxygen" | "javadoc" }?,
        text
    }





    # Preprocessor elements

    # cpp:define
    CPPDefineNamed = element cpp:define {
        text,
        element cpp:directive { "define" },
        CommentOrText*,
        CPPMacroAny,
        CommentOrText*,
        (CPPValue | CPPNumber)?
    }

    CPPDefineNoName = element cpp:define {
        text,
        element cpp:directive { "define" }
    }

    # cpp:macro
    CPPMacroAny = (CPPMacroFunctionCall | CPPMacroSimpleName)

    CPPMacroSimpleName = element cpp:macro {
        SimpleName
    }

    CPPMacroFunctionCall = element cpp:macro {
        SimpleName,
        MacroParameterList
    }


    # cpp:value
    CPPValue = element cpp:value { CommentOrText* }

    
    # cpp:number
    CPPNumber = element cpp:number { CommentOrText* }


    # cpp:directive
    CPPDirective = element cpp:directive {
        "define" |
        "if" |
        "elif"
    }

    
    # cpp:if
    CPPIf = element cpp:if {
        text,
        element cpp:directive { "if" },
        CommentOrText*,
        Expr?
    }


    # cpp:elif
    CPPElIf = element cpp:elif {
        text,
        element cpp:directive { "elif" },
        CommentOrText*,
        Expr?
    }


    # cpp:else
    CPPElse = element cpp:else {
        text,
        element cpp:directive { "else" },
        AnyContent*
    }


    # cpp:endif
    CPPEndIf = element cpp:endif {
        text,
        element cpp:directive { "endif" }
    }


    # cpp:endregion
    CPPEndRegion = element cpp:endregion {
        text,
        element cpp:directive { "endregion" }
    }


    # cpp:error
    CPPError = element cpp:error {
        text,
        element cpp:directive { "error" },
        AnyContent*
    }


    # cpp:ifdef
    CPPIfDef = element cpp:ifdef {
        text,
        element cpp:directive { "ifdef" },
        CommentOrText*,
        SimpleName?
    }


    # cpp:ifndef
    CPPIfNDef = element cpp:ifndef {
        text,
        element cpp:directive { "ifndef" },
        CommentOrText,
        SimpleName?
    }


    # cpp:include
    CPPInclude = element cpp:include {
        text,
        element cpp:directive { "include" },
        CommentOrText,
        CPPFile?
    }


    # cpp:file
    CPPFile = element cpp:file {
        CommentOrText
    }


    # cpp:line
    CPPLine = (CPPLineCAndCPP | CPPLineCS)

    CPPLineCAndCPP = element cpp:line {
        text,
        element cpp:directive { "line" },
        CommentOrText*,
        CPPNumber?,
        CommentOrText*,
        CPPFile?
    }

    CPPLineCS = element cpp:line {
        text,
        element cpp:directive { "line" },
        CommentOrText*,
        SimpleName
    }

    # cpp:pragma
    CPPPragma = element cpp:pragma {
        text,
        element cpp:directive { "pragma" },
        (SimpleName | CPPLiteral | CommentOrText)*
    }
    
    # cpp:literal
    CPPLiteral = element cpp:literal { text }


    # cpp:region
    CPPRegion = element cpp:region {
        text,
        element cpp:directive { "region" },
        (SimpleName | CPPLiteral | CommentOrText)*
    }


    # cpp:endif
    CPPUndef = element cpp:undef {
        text,
        element cpp:directive { "undef" },
        CommentOrText*,
        SimpleName?
    }


    # cpp:warning
    CPPWarning = element cpp:warning {
        text,
        element cpp:directive { "warning" },
        (SimpleName | CPPLiteral | CommentOrText)*
    }


    # src namespace elements    
    If = (IfPartial | IfTypical)

    IfTypical = element if {
        AnyCPPOrComment*,
        Condition?,
        AnyCPPOrComment*,
        Then?,
        (Elseif | AnyCPPOrComment)*,
        (Else |  AnyCPPOrComment)*
    }

    IfPartial = element if {
        AnyCPPOrComment*, EmptyStmt, AnyCPPOrComment*
    }

    Condition = element condition {
        AnyCPPOrComment*,
        (Expr | Decl)?,
        AnyCPPOrComment*
    }
    
    Then = element then {
        AnyCPPOrComment*,
        AnyBlock,
        AnyCPPOrComment*
    }


    
    ASM = element asm {
        AnyContent*
    }

    # Both static and regular asserts
    Assert = element assert {
        attribute type { "static" }?,
        AnyContent*
    }

    # Block and pseudo block
    AnyBlock = (PseudoBlock | Block)

    Block = element block {
        AnyContent*
    }

    PseudoBlock = element block {
        attribute type { "pseudo" },
        AnyContent*
    } 

    # include C#, java and C breaks
    Break = element break {
        AnyContent*
    }

    Case = element case {
        AnyContent*
    }

    # this include all types of catch statement
    # from all covered languages.
    CatchBlock = element catch {
        AnyContent*
    }

    # this doesn't include the Checked used like a call.
    Checked = element checked {
        AnyContent*
    }

    # For now (or until I learn exactly how to handle parts of mixed content)
    # this includes java annotations.
    Interface = element class {
        attribute type { "interface" },
        AnyContent*
    }

    Class = element class {
        AnyContent*
    }

    ClassDecl = element class_decl {
        AnyContent*
    }
    
    # This is a special case for a constructor
    # because the other case doesn't work outside of a class.
    ConstructorQualified = element constructor {
        AnyContent*
    }

    ConstructorDecl = element constructor_decl {
        AnyContent*
    }

    # This includes Javas goto-continue stmt
    Continue = element continue {
        AnyContent*
    }

    DeclStmt = element decl_stmt {
        AnyContent*
    }

    DefaultLabel = element default {
        AnyContent*
    }

    DestructorQualified = element destructor {
        AnyContent*
    }

    Destructor = element destructor {
        AnyContent*
    }
    
    DestructorDecl = element destructor_decl {
        AnyContent*
    }

    Do = element do {
        AnyContent*
    }

    Else = element else {
        AnyContent*
    }

    EmptyStmt = element empty_stmt {
        text
    }

    Elseif = element elseif {
        AnyContent*
    }

    Enum = element enum {
        attribute type { "class" }?,
        AnyContent*
    }
    
    ExprStmt = element expr_stmt {
        AnyContent*
    }
    
    ExternBlock = element extern {
        AnyContent*
    }
    
    FinallyBlock = element finally {
        AnyContent*
    }

    Fixed = element fixed {
        AnyContent*
    }

    For = element for {
        AnyContent*
    }

    ForEach = element foreach {
        AnyContent*
    }

    Function = element function {
        attribute type { "operator" }?,
        AnyContent*
    }

    FunctionDecl = element function_decl {
        attribute type { "operator" }?,
        AnyContent*
    }

    GenericSelection = element generic_selection {
        AnyContent*
    }

    Goto = element goto {
        AnyContent*
    }

    Import = element import {
        AnyContent*
    }

    Label = element label {
        AnyContent*
    }
    
    LINQ = element linq {
        AnyContent*
    }   

    Lock = element lock {
        AnyContent*
    }

    Namespace = element namespace {
        AnyContent*
    }

    Package = element package {
        AnyContent*
    }

    Private = element private {
        AnyContent*
    }

    Protected = element protected {
        AnyContent*
    }

    Public = element public {
        AnyContent*
    }

    Return = element return {
        AnyContent*
    }

    StaticInitBlock = element static {
        AnyContent*
    }

    Struct = element struct {
        AnyContent*
    }

    StructDecl = element struct_decl {
        AnyContent*
    }

    Switch = element switch {
        AnyContent*
    }

    Synchronized = element synchronized {
        AnyContent*
    }

    Throw = element throw {
        AnyContent*
    }

    Try = element try {
        AnyContent*
    }

    Typedef = element typedef {
        AnyContent*
    }

    # This doesn't include the function call like syntax.
    UnChecked = element unchecked {
        AnyContent*
    }

    Union = element union {
        AnyContent*
    }

    UnionDecl = element union_decl {
        AnyContent*
    }

    Unsafe = element unsafe {
        AnyContent*
    }

    UsingStmt = element using {
        AnyContent*
    }

    UsingDirective = element using {
        AnyContent*
    }

    While = element while {
        AnyContent*
    }

    Macro = element macro {
        AnyContent*
    }

    Escape = element escape {
        attribute char { text }
    }

    Attribute = element attribute {
        AnyContent*
    }

    Template = element template {
        AnyContent*
    }

    Lambda = element lambda {
        AnyContent*
    }

    # Objective C related stuff
    Forever = element forever {
        AnyContent*
    }

    Dynamic = element dynamic {
        AnyContent*
    }

    # src:name 
    SimpleName = element name { text }

    # parameter_list
    MacroParameterList = element parameter_list {
        text,
        (MacroParameter, (text, MacroParameter)*)?,
        text
    }

    # src:param
    MacroParameter = element param {
        AnyContent*
    }

    # src:expr
    Expr = element expr {
        AnyContent*
    }

    # src:decl
    Decl = element decl {
        AnyContent*
    }

    Literal = element literal {
        attribute type { "number" | "string" | "null" | "boolean" | "char" }?,
        text
    }
} # End Grammar
